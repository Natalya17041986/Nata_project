from ast import arg
from re import X
from turtle import color
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px

hh_data = pd.read_csv()
print(hh_data.head())
print(hh_data.info())
print(hh_data.shape)
print(hh_data.describe())
print(hh_data['Опыт работы'].nunique())
print(hh_data['Ищет работу на должность:'].mode())

# преобразование данных
# Начнём с простого — с признака «Образование и ВУЗ». Его текущий формат — это: <Уровень образования год выпуска
# ВУЗ специальность...>. Например:
# Высшее образование 2016 Московский авиационный институт (Национальный исследовательский университет
# Неоконченное высшее образование 2000 Балтийская государственная академия рыбопромыслового флота
# Нас будет интересовать только уровень образования.
# Создайте с помощью функции-преобразования новый признак «Образование», который должен иметь четыре категории: 
# «высшее», «неоконченное высшее», «среднее специальное» и «среднее».
# Выполните преобразование, ответьте на контрольные вопросы и удалите признак «Образование и ВУЗ».

def get_education(arg):
    arg = ' ' .join(arg.split(' ')[:3])
    if 'Высшее' in arg:
        return 'высшее'
    elif 'Неоконченное высшее' in arg:
        return 'неоконченное высшее'
    elif 'Среднее специальное' in arg:
        return 'среднее специальное'
    elif 'Среднее образование' in arg:
        return 'среднее'
hh_data['Образование'] = hh_data['Образование и ВУЗ'].apply(get_education)

data_hh = hh_data.drop('Образование и ВУЗ', axis=1)

print(data_hh['Образование'].value_counts()['среднее'])

# Теперь нас интересует столбец «Пол, возраст». Его текущий формат: <Пол , возраст, дата рождения>. Например:
# Мужчина , 39 лет , родился 27 ноября 197
# Женщина , 21 год , родилась 13 января 2000
# Как вы понимаете, нам необходимо выделить каждый параметр в отдельный столбец..
# Создайте два новых признака «Пол» и «Возраст». При этом важно учесть:
# Признак пола должен иметь два уникальных строковых значения: М — мужчина, Ж — женщина
# Признак возраста должен быть представлен целыми числами.
# Выполните преобразование, ответьте на контрольные вопросы и удалите признак «Пол, возраст» из таблицы.

def gender(arg):
    arg = ' ' .join(arg.split(' ')[:1])
    if 'Женщина' in arg:
        return 'Ж'
    else:
        return 'М'

data_hh['Пол'] = data_hh['Пол, возраст'].apply(gender)


def age(arg):
    arg_splitted = arg.split(' ')
    words=['год', 'года', 'лет']
    for index, item in enumerate (arg_splitted):
        if item in words:
            return int(arg_splitted[index-1])
        
data_hh['Возраст'] = data_hh['Пол, возраст'].apply(age)

print(round(data_hh['Пол'].value_counts(normalize=True)['Ж'] * 100, 2))
print(data_hh['Возраст'].mean())


# Следующим этапом преобразуем признак «Опыт работы». Его текущий формат: <Опыт работы: n лет m месяцев, 
# периоды работы в различных компаниях…>.
# Из столбца нам необходимо выделить общий опыт работы соискателя в месяцах, новый признак назовём «Опыт работы (месяц)».

def experience(arg):
    if arg is np.nan or arg == 'Не указано':
        return None
    year_words=['год', 'года', 'лет']
    month_words=['месяц', 'месяца', 'месяцев']
    arg_splitted = arg.split(' ')[:7]
    years = 0
    months = 0
    for index, item in enumerate (arg_splitted):
        if item in year_words:
            years = int(arg_splitted[index-1])
        if item in month_words:
            months = int(arg_splitted[index-1])
    return int(years*12 + months)


data_hh['Опыт работы (месяц)'] = data_hh['Опыт работы'].apply(experience)

print(data_hh['Опыт работы (месяц)'].median())

# Хорошо идём! :) Следующий на очереди — признак «Город, переезд, командировки».
# Информация в нём представлена в следующем виде: <Город , (метро) , готовность к переезду (города для переезда) , 
# готовность к командировкам>.
# В скобках указаны необязательные параметры строки. Например, можно встретить следующие варианты:
# Москва , не готов к переезду , готов к командировкам
# Москва , м. Беломорская , не готов к переезду, не готов к командировкам
# Воронеж , готов к переезду (Сочи, Москва, Санкт-Петербург) , готов к командировкам
# Создадим отдельные признаки «Город», «Готовность к переезду», «Готовность к командировкам». При этом важно учесть:
# Признак «Город» может содержать только четыре категории: «Москва», «Санкт-Петербург» и «город-миллионник» 
# (их список ниже), остальные обозначьте как «другие». 

million_cities = ['Новосибирск', 'Екатеринбург', 'Нижний Новгород', 'Казань', 'Челябинск', 
                  'Омск', 'Самара', 'Ростов-на-Дону', 'Уфа', 'Красноярск', 'Пермь', 'Воронеж', 'Волгоград' ]


# функция для вычленения признака города

def city(arg):
    arg = ' ' .join(arg.split(' ')[:1])
    if 'Москва' in arg:
        return 'Москва'
    elif 'Санкт-Петербург' in arg:
        return 'Санкт-Петербург'
    elif arg in million_cities:
        return 'город-миллионник'
    else:
        return 'другие'
            
data_hh['Город'] = data_hh['Город, переезд, командировки'].apply(city)

# функция для вычленения признака готовности к переезду
def cross_over(arg):
    if 'не' in arg:
        return False
    elif 'Не' in arg:
        return False
    else:
        return True
    
data_hh['Готовность к переезду'] = data_hh['Город, переезд, командировки'].apply(cross_over)

# функция для вычленения признака готовности к командировам

def business_trip(arg):
    if ('командировка' in arg):
        if ('не готов к командировкам' in arg) or('не готова к командировкам' in arg):
            return False
        else: 
            
            return True
    else:
        return False

data_hh['Готовность к командировкам'] = data_hh['Город, переезд, командировки'].apply(business_trip)

data_hh = data_hh.drop('Город, переезд, командировки', axis=1)

print(data_hh.loc[1548, 'Город'])
print(data_hh.loc[1548, 'Готовность к переезду'])
print(data_hh.loc[1548, 'Готовность к командировкам'])

print(round(data_hh['Город'].value_counts(normalize=True)['Санкт-Петербург'] * 100))

print(round(data_hh[
    data_hh['Готовность к переезду'] & data_hh['Готовность к командировкам']].shape[0] / data_hh.shape[0] *100, 2))

# Рассмотрим поближе признаки «Занятость» и «График».
# Сейчас признаки представляют собой набор категорий желаемой занятости (полная занятость, частичная занятость, 
# проектная работа, волонтёрство, стажировка) и желаемого графика работы (полный день, сменный график, гибкий график, 
# удалённая работа, вахтовый метод).
# На сайте hh.ru соискатель может указывать различные комбинации данных категорий, например:
# полная занятость, частичная занятость
# частичная занятость, проектная работа, волонтёрство;
# полный день, удалённая работа;
# вахтовый метод, гибкий график, удалённая работа, полная занятость.
# Такой вариант признаков имеет множество различных комбинаций, а значит, множество уникальных значений, 
# что мешает анализу. Нужно это исправить!
# Давайте создадим признаки-«мигалки» для каждой категории: если категория присутствует в 
# списке желаемых соискателем, то в столбце на месте строки рассматриваемого соискателя ставится True, иначе — False.

employments = ['полная занятость', 'частичная занятость',
              'проектная работа', 'волонтерство', 'стажировка']
charts = ['полный день', 'сменный график', 
         'гибкий график', 'удаленная работа',
         'вахтовый метод']
for employment, chart in zip(employments, charts):
    data_hh[employment] = data_hh['Занятость'].apply(lambda x: employment in x)
    data_hh[chart] = data_hh['График'].apply(lambda x: chart in x)
data_hh = data_hh.drop('Занятость', axis=1)
data_hh = data_hh.drop('График', axis=1)
print(data_hh[data_hh['проектная работа'] & data_hh['волонтерство']].shape[0])
print(data_hh[data_hh['вахтовый метод'] & data_hh['гибкий график']].shape[0])

# Наконец, мы добрались до самого главного — признака заработной платы «ЗП». 
# В чём наша проблема? — В том, что помимо желаемой заработной платы соискатель указывает валюту, 
# в которой он хотел бы её получать, например:
# 30 000 руб.
# 50 000 грн.;
# 550 USD.
# Нам бы хотелось видеть заработную плату в единой валюте, например в рублях. Возникает вопрос: 
# а где взять курс валют по отношению к рублю?
# На самом деле язык Python имеет в арсенале огромное количество возможностей получения данной информации: 
# от обращения к API Центробанка, до использования специальных библиотек, например pycbrf. 
# Однако в рамках нашего проекта эти темы мы рассматривать не будем.
# Поэтому просто обратимся к профильным интернет-ресурсам для получения данных о курсе в виде текстовых файлов. 
# Например, MDF.RU: данный ресурс позволяет удобно экспортировать данные о курсах различных валют и акций 
# за указанные периоды в виде csv. Мы уже сделали выгрузку курсов валют, которые встречаются в наших данных 
# за период с 29.12.2017 по 05.12.2019: скачать её вы можете здесь.
# Создайте новый DataFrame из скачанного файла. В полученной таблице нас будут интересовать столбцы:
# currency — наименование валюты в ISO-кодировке;
# date — дата;
# proportion — пропорция;
# close — цена закрытия (последний зафиксированный курс валюты на указанный день).
# Перед вами таблица соответствия наименований иностранных валют в наших данных и их общепринятых сокращений, 
# которые представлены в файле с курсами валют.
# Пропорция — это число, отражающее, скольким единицам валюты соответствует курс в таблице с курсами. 
# Например для казахстанского тенге курс на 20.08.2019 составляет 17.197 руб. за 100 тенге, 
# тогда итоговый курс равен: 17.197 / 100 = 0.17197 руб. за 1 тенге.

exhcange_rate_data = pd.read_csv('data/ExchangeRates.csv' , sep=',')

exhcange_rate_data = exhcange_rate_data[
    ['currency' , 'date' , 'proportion', 'close']
]

print(exhcange_rate_data.info())  

data_hh['Обновление резюме'] = pd.to_datetime(data_hh['Обновление резюме'])
data_hh['Дата резюме'] = data_hh['Обновление резюме'].dt.date

print(data_hh['ЗП'])

def get_salary(arg):
    salary = float(arg.split(' ')[0])
    return salary


data_hh['ЗП сумма'] = data_hh['ЗП'].apply(get_salary)

print(data_hh['ЗП сумма'])

def get_salary_cur(arg):
    currency_dict = {
        'USD': 'USD', 'KZT': 'KZT',
        'грн': 'UAH', 'белруб': 'BYN',
        'EUR': 'EUR', 'KGS': 'KGS',
        'сум': 'UZS', 'AZN': 'AZN'
    }
    curr = arg.split(' ')[1].replace('.', '')
    if curr == 'руб':
        return 'RUB'
    else:
        return currency_dict[curr]
    
data_hh['ЗП валюта'] = data_hh['ЗП'].apply(get_salary_cur)

print(data_hh['ЗП валюта'])   

data_hh = data_hh.merge(
    exhcange_rate_data, 
    left_on=['ЗП валюта', 'Дата резюме'],
    right_on=['currency', 'date',], 
    how='left'
)

print('Число строк: ', data_hh.shape[0])
print('Число столбцов: ', data_hh.shape[1])

data_hh['close'] = data_hh['close'].fillna(1)
data_hh['proportion'] = data_hh['proportion'].fillna(1)
data_hh['ЗП в рублях'] = data_hh['close'] * data_hh['ЗП сумма'] / data_hh['proportion']
data_hh = data_hh.drop(['ЗП', 'ЗП сумма', 'ЗП валюта'], axis=1)

print(round(data_hh['ЗП в рублях'].median()/1000))

fig = px.histogram(
    data_hh,
    x = 'Возраст',
    title='Гистограмма рспределения возраста соискателей',
    marginal='box'
)
fig.show()

# Чему равна мода распределения? Мода распределения равна 3 годам
# Каковы предельные значения признака, в каком примерном интервале находится возраст большинства соискателей? 
# Предельные значения возраста находятся в интервале от 14 до 100 лет. Большин ство соискателей в возрасте от 28 до 31 года.
# Есть ли аномалии для данного признака? Если есть, то какие значения вы бы причислили к таковым? 
# Анамалии есть: один соискатель в возрасте 77 леи и один в возрасте 100 лет, так же к 
# аномалиям можно отнести соискателей в возрасте от 68 до 73

fig = px.histogram(
    data_hh,
    x='Опыт работы (месяц)',
    title='Распределение опыта работы соискателей',
    marginal='box',
)
fig.show()


# Чему равна мода распределения? Наибольшее количество соискателей с опытом работы от 80 до 84 месяцв
# Каковы предельные значения признака, в каком примерном интервале находится опыт работы большинства соискателей?
# Основная масса соискателей с опытом работы от 59 до 94 месяцев
# Есть ли аномалии для признака? Если есть, то какие значения вы бы причислили к таковым?
# К аномалиям я бы отнесла соискателей с опытом работы от 500 месяцев

fig = px.histogram(
    data_hh,
    x='ЗП в рублях',
    title='Распределение заработной платы соискателей',
    marginal='box',
)
fig.show()

# Чему равна мода распределения?
# Каковы предельные значения признака, в каком примерном интервале находится заработная плата большинства соискателей?
# Есть ли аномалии для признака заработной платы? Если есть, то какие значения вы бы причислили к таковым?

histogram_data = data_hh[data_hh['ЗП в рублях'] < 1000000]

fig = px.histogram(
    histogram_data,
    x='ЗП в рублях',
    color='Образование',
    height=800,
    marginal='box'
)

fig.show()

# Постройте диаграмму, которая показывает зависимость медианной желаемой заработной платы («ЗП (руб)») от 
# уровня образования («Образование»).
# Используйте для диаграммы данные о резюме, где желаемая заработная плата меньше 1 миллиона рублей.
# Сделайте выводы по представленной диаграмме:
# Для каких уровней образования наблюдаются наибольшие и наименьшие уровни желаемой заработной платы?
# Наибольший уровень ЗП наблюдается у соискателесь с высшим и неоконченным высшим образованием. 
# Наименьший для среднеспециального образования
# Как вы считаете, важен ли признак уровня образования при прогнозировании заработной платы? Конечно важен

histogram_data = data_hh[data_hh['ЗП в рублях'] < 1000000]

fig = px.histogram(
    histogram_data,
    x='ЗП в рублях',
    color='Город',
    height=800,
    marginal='box'
)

fig.show()

# Постройте диаграмму, которая показывает распределение желаемой заработной платы («ЗП (руб)») в 
# зависимости от города («Город»). Используйте для диаграммы данные о резюме, где желаемая заработная 
# плата меньше 1 миллиона рублей.
# Сделайте выводы по полученной диаграмме:
# Как соотносятся медианные уровни желаемой заработной платы и их размах в городах? 
# Самая большая медианная зп в МскБ самая маленькая в СПб и городах миллионниках, 
# в других городах мелианная значительно выше чем в СПб и городах милионникаъ
# Как вы считаете, важен ли признак города при прогнозировании заработной платы? Думаю, важен только для Мск


bar_data = data_hh.groupby(['Готовность к переезду' , 'Готовность к командировкам'] , as_index=False)['ЗП в рублях'].median()

fig = px.bar(
    bar_data,
    y='ЗП в рублях',
    x = 'Готовность к переезду',
    color = 'Готовность к командировкам',
    title='Медианная з/п по готовности к командировкам/переезду'
)

fig.show()

# Постройте многоуровневую столбчатую диаграмму, которая показывает зависимость медианной заработной платы 
# («ЗП (руб)») от признаков «Готовность к переезду» и «Готовность к командировкам». Проанализируйте график, 
# сравнив уровень заработной платы по категориям.


# Постройте сводную таблицу, иллюстрирующую зависимость медианной желаемой заработной платы от возраста («Возраст») 
# и образования («Образование»).
# По полученной сводной таблице постройте тепловую карту.
# Проанализируйте тепловую карту, сравнив показатели внутри групп.

pivot = data_hh.pivot_table(
    values='ЗП в рублях',
    columns='Образование',
    index='Возраст',
    aggfunc='median',
    fill_value=0
)

fig = px.imshow(pivot)

fig.show()

# Постройте диаграмму рассеяния, показывающую зависимость опыта работы («Опыт работы (месяц)») от возраста («Возраст»).
# Опыт работы переведите из месяцев в года, чтобы признаки были в едином масштабе.
# Постройте на графике дополнительно прямую, проходящую через точки (0, 0) и (100, 100). 
# Данная прямая соответствует значениям, когда опыт работы равен возрасту человека. 
# Точки, лежащие на этой прямой и выше неё, — аномалии в наших данных (опыт работы больше либо равен возрасту соискателя).

data_hh['Опыт работы (год)'] = data_hh['Опыт работы (месяц)'] / 12
print(data_hh['Опыт работы (год)'])
print(data_hh.info())

import seaborn as sns
import matplotlib.pyplot as plt

sns.lineplot(x=[0, 100], y=[0, 100])
ax = sns.scatterplot(
    data=data_hh, 
    x='Возраст',
    y='Опыт работы (год)',
)
ax.set_title('Зависимость опыта работы от возраста')

plt.show()


## ОЧИСТКА ДАННЫХ

# Начнём с дубликатов в наших данных. Найдите полные дубликаты в таблице с резюме и удалите их.

dupl_columns = list(data_hh.columns)

mask = data_hh.duplicated(subset=dupl_columns)
data_hh_duplicates = data_hh[mask]
print(f'Число найденных дубликатов: {data_hh_duplicates.shape[0]}')

duplicates = data_hh[data_hh.duplicated(subset=data_hh.columns)]
data_hh_dropduplicates = data_hh.drop_duplicates()
print(duplicates.shape[0])

# Займёмся пропусками. Выведите информацию о числе пропусков в столбцах.
# Сколько пропусков в столбце «Опыт работы (месяц)»

null_data = data_hh_dropduplicates.isnull().sum()
print(null_data[null_data > 0])

# Итак, у нас есть пропуски в трёх столбцах: «Опыт работы (месяц)», «Последнее/нынешнее место работы», 
# «Последняя/нынешняя должность». Поступим следующим образом: удалите строки, где есть пропуск в столбцах с 
# местом работы и должностью.
# Пропуски в столбце с опытом работы заполните медианным значением.

data_hh_drop = data_hh_dropduplicates['Последнее/нынешнее место работы'].dropna(how='any')
data_hh_drop = data_hh_drop['Последняя/нынешняя должность'].dropna(how='any')

values = {
    'Опыт работы (месяц)': data_hh_drop['Опыт работы (месяц)'].median()
    }

data_hh_new = data_hh_drop.fillna(values)


