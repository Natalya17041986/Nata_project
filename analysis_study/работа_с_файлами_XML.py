import xml.etree.ElementTree as ET # Импортируем модуль ElementTree

# Для работы со структурой файла menu.xml считаем его содержимое в переменную tree, выполнив код:

import xml.etree.ElementTree as ET # Импортируем модуль ElementTree
tree = ET.parse('data/menu.xml')

# Запишем в переменную root корневой узел дерева tree и посмотрим, как выглядит содержимое переменной root,
# для чего выполним код:

root = tree.getroot()
print(root)

# Мы видим, что в корне находится 'menu'. Всё правильно, мы и предполагали увидеть именно это. 

# Какой тип у этого объекта? Если мы вызовем встроенный в Python метод type() и передадим ему root , 
# то увидим, что это тип xml.etree.ElementTree.Element. Такой тип будет у любого узла в дереве.

print((type(root)))

# Для того чтобы посмотреть список потомков корневого узла, выполним следующий код:

print(list(root))

# Если у узла нет потомков, то вернётся пустой список — [].

print(len(list(root)))

# Итак, использование list(root) возвращает список потомков указанного узла. У узла root, 
# который представляет меню, два потомка, а именно — два блюда, которые представлены тегами dish.
# Для того чтобы получить список потомков второго блюда в нашем меню и вывести его на экран, выполним код:

print(list(root[1]))

# Таким образом, у второго потомка узла root —  три потомка.

# Как было сказано ранее, у узлов могут быть параметры, или атрибуты. 
# Например, у узлов dish есть атрибут name, который хранит название блюда.
# Мы можем непосредственно обратиться к атрибутам, используя attrib.
# Выведем на экран атрибуты первого блюда из меню:

print(root[0].attrib)

# В XML-узлах часто хранятся количественные показатели. Эти показатели хранятся в виде текста, 
# и прочитать их можно, обратившись к атрибуту text у соответствующего объекта типа ElementTree.Element.
# Например, возьмём узел price первого блюда из меню:

print(root[0][0])


# Теперь прочитаем значение этого узла с помощью text:

print(root[0][0].text)

# Например, в данном случае можно обернуть значение стоимости в int() или float().

# Если вы хотите прочитать наименование тега конкретного узла, необходимо использовать tag. Например, получим наименование тега корневого узла:

print(root.tag)

# Какое наименование имеет тег узла root[0][2]?

print(root[0][2].tag)

# На этом шаге мы решим задачу вывода на экран наименование всех блюд из меню,
# а также информацию о них (иными словами, нам необходимо обойти дерево и вывести на экран значения его листьев).
# Используя цикл for, автоматизируем обход дерева. Для этого напишем следующий код:

for dish in root:
    for param in dish:
        print(dish.attrib['name'], param.tag, param.text)
    print()
    
# В этом коде реализован следующий алгоритм:
# В первом (внешнем) цикле перебираем потомков корня дерева (root). Потомки перебираются последовательно 
# при помощи переменной dish. Это отдельные блюда из меню
# Во втором (вложенном) цикле аналогичным образом перебираем потомков каждого блюда. Этими потомками являются 
# параметры блюда — его цена (price), вес (weight) и класс (class).
# После этого выводим на экран название блюда (значение атрибута name), название очередного параметра (tag) 
# и его значение (text).
# Дополнительная функция print() в цикле верхнего уровня предназначена для организации более удобного 
# восприятия информации — между отдельными блюдами будет выведена пустая строка.


# Реализуем следующий алгоритм:
# Загрузить XML-структуру файла menu.xml в переменную root.
# Создать пустой список df_list (в него будем добавлять строчки итоговой таблицы).
# Заранее создать список column_names с именами столбцов — название блюда (name), его цена (price), вес (weight) и класс (class).
# В цикле организовать обход xml-дерева из корня по всем потомкам.
# На каждой итерации цикла сформировать в виде списка строку таблицы, содержащую информацию: наименование блюда (атрибут name узла dish) и значения потомков этого узла — узлов price, weight, class.
# Добавить сформированную строку в список df_list, используя метод append().
# Сформировать из вложенного списка DataFrame. Имена для столбцов взять из списка column_names.

import xml.etree.ElementTree as ET
tree = ET.parse('data/menu.xml')
root = tree.getroot()

import pandas as pd
column_names = ['name', 'price', 'weight', 'class']
df_list = []

for dish in root:
    row = [dish.attrib['name'], dish[0].text, dish[1].text, dish[2].text]
    df_list.append(row)
    df = pd.DataFrame(df_list, columns=column_names)
print(df)

# Воссоздадим структуру нашего исходного XML-файла с нуля,  руководствуясь общими рекомендациями.
# Чтобы создать корень дерева, используем метод Element() из класса ElementTree:

import xml.etree.ElementTree as ET

new_root = ET.Element('menu')
print(new_root)

# Теперь мы можем добавлять новые узлы в наше дерево, используя метод SubElement() из того же класса.
# Добавим в наше меню двух потомков корневого узла, которые будут представлять два блюда, то есть будут узлами dish:

dish1 = ET.SubElement(new_root, 'dish', name='Кура')
dish2 = ET.SubElement(new_root, 'dish', name='Греча')
print(list(new_root))

# В метод SubElement() мы передали первым аргументом узел, к которому добавляем потомка, вторым аргументом — 
# наименование нового тега (dish),  третьим аргументом — наименование атрибута нового узла( name ) и его значение.

# Аналогичным образом можно добавлять новые узлы к любым существующим узлам, не только к корню.

# Добавим в создаваемую структуру по три потомка (атрибута) к двум новым узлам, которые будут содержать 
# информацию о блюде — о его цене (price), весе (weight) и классе (class), а также значение этих атрибутов:

price1 = ET.SubElement(dish1, "price").text = "40"
weight1 = ET.SubElement(dish1, "weight").text = "300"
class1 = ET.SubElement(dish1, "class").text = "Мясо"
print(list(dish1))

price2 = ET.SubElement(dish2, "price").text = "20"
weight2 = ET.SubElement(dish2, "weight").text = "200"
class2 = ET.SubElement(dish2, "class").text = "Крупа"
print(list(dish2))

# Проверим визуально корректность созданной нами структуры, выполнив фрагмент кода, разработанного ранее:

for dish in new_root:
    for param in dish:
        print(dish.attrib['name'], param.tag, param.text)
    print()
    
# В финале работы с файлом XML-формата запишем созданную нами структуру как XML-файл на диск.
# Преобразуем созданный нами объект типа ElementTree.Element в строку c помощью метода tostring(), 
# передав наше новое дерево как аргумент. Сохраним эту строку на диске, используя стандартные средства Python::

new_root_string = ET.tostring(new_root)
with open("data/new_menu.xml", "wb") as f:
    f.write(new_root_string)
    
# Возможно, вы увидите проблему, связанную с кодировкой. Что делать в этом случае? Как вариант — 
# записать файл, используя сам класс ElementTree() :

ET.ElementTree(new_root).write('data/new_menu_good.xml', encoding="utf-8")

# Для этого мы передаём в класс ElementTree() наше дерево (не его строковое представление) и вызываем метод write().
# В метод мы передаём путь к новому файлу и нужную нам кодировку.