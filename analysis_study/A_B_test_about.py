## ОПИСАНИЕ ЗАДАЧИ

# Проводится A/B-тестирование для двух вариантов рекомендаций сопутствующих товаров в профиле товара некоторого интернет-магазина. 

# Вариант 1. Дополнительные товары рекомендуются на основе статистических данных уже совершённых покупок — товары, которые другие пользователи часто покупают с основным. 
# Вариант 2. Дополнительные товары рекомендуются на основе совершённых пользователем ранее покупок с помощью ML-модели.
# Варианты сравниваются по доле пользователей, которые добавляют хотя бы один из предложенных товаров в корзину (метрикой является конверсия действия «добавить в корзину сопутствующий товар»).

# Для этого пользователи были разделены на две группы. 

# Контрольной (группе А) доступен первый вариант рекомендаций.
# Тестовой (группе B) доступен второй вариант. 
# Предполагается, что все условия и принципы проведения A/B-теста были соблюдены, то есть:

# ✔️ выборка имеет достаточный для принятия решения объём;

# ✔️ выбран достаточный интервал времени для тестирования;

# ✔️ группы максимально сбалансированы;

# ✔️ внешнее вмешательство минимально.

# Итак, в результате проведения A/B-тестирования были получены следующие данные:

from random import sample
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

ab_data = pd.read_csv('data/ab_data.csv')

print(ab_data.head())

# Посмотрим тип данных и содержание каждого столбца, для этого применим к датафрейму метод info():

print(ab_data.info())

# Итак, в наших данных нет пропусков, однако нам нужно перевести столбец с информацией о дате события (timestamp) 
# в формат datetime. Напомним: для этого мы можем воспользоваться функцией pandas to_datetime:

ab_data['timestamp'] = pd.to_datetime(ab_data['timestamp'], format='%Y-%m-%d')

# В итоге мы получили таблицу, в которой отображены входы клиента на сайт (сессия) и его действия. 
# Для того, чтобы получить показатель конверсии в группах на каждый день, нам необходимо предварительно 
# сгруппировать наши данные по дате и группе и вычислить количество пользователей, заходивших на сайт, 
# и суммарное количество совершённых целевых действий. 
# Дополнительно для удобства сбросим индекс на сгруппированной таблице c помощью метода reset_index() и 
# переименуем столбец user_id в users_count с помощью метода rename().

daily_data = ab_data.groupby(['timestamp','group']).agg({
    'user_id':'count',
    'converted':'sum'
}).reset_index().rename(columns={'user_id': 'users_count'})

print(daily_data.head())

# Примечание. Количество пользователей в день в контрольной и тестовой группе определяется как количество значений 
# в столбце user_id в сгруппированных данных, а количество совершённых целевых действий — это просто сумма 
# по столбцу converted (1 в строке означает положительный исход, то есть целевое действие было совершено,
# а 0 — отрицательный исход; просуммировав все 1 и 0 в группе, получим количество положительных исходов).

# Для завершения этапа подготовки данных к анализу нам осталось рассчитать конверсию на каждый день проведения 
# A/B-тестирования. Напомним: ежедневная конверсия рассчитывается как отношение числа посетителей сайта, 
# выполнивших на нём какие-либо целевые действия в день, к ежедневному общему числу посетителей сайта, 
# умноженная на 100 %:
# \[conv_{t} = \frac{N_{t}^{+}}{N_{t}} \times 100\ %\]
# \(N_{t}^{+}\) — количество посетителей сайта, выполнивших целевое действие в день \(t\);
# \(N_t\) — общее количество посетителей сайта в день \(t\);
# \(conv_t\) — конверсия в день \(t\).

# Рассчитайте конверсию на каждый день по приведённой формуле. Результат занесите в столбец conversion. 
# Чему была равна конверсия (в процентах) в группе А 5 января 2017 года? Ответ округлите до второго знака после запятой.

daily_data['conversion'] = daily_data['converted']/daily_data['users_count'] * 100

print(round(daily_data[
    (daily_data['timestamp'] == '2017-01-05') & (daily_data['group'] == 'A')
]['conversion'], 2))

print(daily_data.head())

# Нам необходимо ответить на вопрос: в какой группе (А или B) показатель конверсии был выше, 
# и на этой основе принять решение о том, какой из вариантов более эффективный. 
# Давайте построим диаграмму boxplot для сравнения параметров распределения ежедневной конверсии по группам. 

# создаём фигуру размером 8x4

fig = plt.figure(figsize=(8, 4)) 

# строим boxplot для conversion по признаку group
boxplot = sns.boxplot(data=daily_data, x='conversion', y='group') 
# задаём подпись к графику
boxplot.set_title('Сравнение конверсии в группах')
# задаём отображение сетки
boxplot.grid()

plt.show()

# Что можно сказать исходя из этого графика? Во-первых, медианное значение ежедневной конверсии в группе 
# А, выше, чем в группе B. Во-вторых, разброс конверсии в группе B несколько больше, чем в группе A.
# Тут неопытный специалист воскликнет: версия рекомендаций А лучше, чем версия B 
# (медиана конверсии варианта А больше, да и разброс поменьше, то есть конверсия более стабильна) — и завершит эксперимент. 
# Но выводы делать ещё рано! И сейчас попробуем понять, почему. 

# Примечание. Прежде чем делать выводы по визуальному представлению данных, всегда обращайте 
# внимание на численные значения показателей. Они могут различаться в масштабе графика, 
# о на практике разница между ними не будет иметь значения. Также всегда стоит убедиться, что в данных 
# нет выбросов (базовый вариант — сравнить медиану и среднее между собой). Далее мы ещё поговорим о 
# стабилизации показателя во времени.

# Давайте вычислим средний и медианный показатель конверсии в контрольной и тестовой группе и 
# умножим результат на 100 (получим результат в процентах):

conversion_piv = daily_data.groupby('group')['conversion'].agg(
    ['mean', 'median']
)

print(conversion_piv)

# Из полученной таблицы видно, что медиана и среднее в каждой группе практически совпадают.
# При этом разница между показателями в группах менее 0.3 %! 

# Итак, давайте применим новые знания к нашим данным и вычислим кумулятивную конверсию, а затем построим её график. 
# Но для начала ради эксперимента посмотрим, как вообще изменялись показатели ежедневной конверсии в каждой 
# группе во времени. Для этого построим линейные графики для каждой группы: по оси абсцисс отложим дату, 
# а по оси ординат — показатель конверсии:

# создаём фигуру размером 8x4
fig = plt.figure(figsize=(8, 4))

# строим lineplot для конверсии во времени в каждой группе
lineplot = sns.lineplot(
    data=daily_data,
    x='timestamp',
    y='conversion',
    hue='group'
)
# задаём подпись к графику
lineplot.set_title('График конверсии по дням')
# задаём поворот меток на оси абсцисс
lineplot.xaxis.set_tick_params(rotation=45)
# задаём отображение сетки
lineplot.grid()

plt.show()

# Для расчёта кумулятивного показателя суммы в Pandas есть специальный метод cumsum(). Давайте посмотрим, 
# как он работает — сначала на данных о ежедневном количестве посетителей для группы А. 
# Выберем данные для группы А и создадим в полученной таблице новый столбец cum_users_count, 
# в который запишем результат работы метода cumsum() по столбцу users_count:

# выделяем данные группы А
daily_data_a = daily_data[daily_data['group'] == 'A']
# считаем кумулятивное количество посетителей
daily_data_a.loc[:, 'cum_users_count'] = daily_data_a['users_count'].cumsum()
# выводим время, количество посетителей и кумулятивное количество посетителей
print(daily_data_a[['timestamp', 'users_count', 'cum_users_count']].head())

# Как сделать такой расчёт для двух групп (А и B) сразу? Воспользуемся методом groupby: сгруппируем данные 
# по признаку группы, и в каждой группе будем вычислять кумулятивные суммы признаков количества посетителей 
# (users_count) и количества совершённых целевых действий (converted). 
# После этого рассчитаем кумулятивную конверсию — это отношение ежедневной кумулятивной суммы количества
# посетителей к ежедневной кумулятивной сумме количества совершённых целевых действий:

# вычисляем кумулятивную сумму количества посетителей
daily_data['cum_users_count'] = daily_data.groupby(['group'])['users_count'].cumsum()
# вычисляем кумулятивную сумму количества совершённых целевых действий
daily_data['cum_converted'] = daily_data.groupby(['group'])['converted'].cumsum()
# вычисляем кумулятивную конверсию
daily_data['cum_conversion'] = daily_data['cum_converted']/daily_data['cum_users_count'] * 100
print(daily_data.head())

# А теперь построим графики кумулятивной конверсии по дням в каждой группе:

# создаём фигуру размером 8x4
fig = plt.figure(figsize=(8, 4))
# строим lineplot для кумулятивной конверсии во времени в каждой группе
lineplot = sns.lineplot(
    x='timestamp', 
    y='cum_conversion', 
    data=daily_data, 
    hue='group'
    )
# задаём подпись к графику
lineplot.set_title('График кумулятивной конверсии по дням')
# задаём поворот меток на оси абсцисс
lineplot.xaxis.set_tick_params(rotation = 45)
# задаём отображение сетки
lineplot.grid(True)

plt.show()

# Что можно сказать теперь? До 2017-01-09 конверсия была нестабильна, но после 2017-11-01 резкие скачки прекратились 
# (кривая графика переходит в прямую). Судя по графику, конверсия группы B стабильно хуже конверсии группы А на всём 
# промежутке времени. 


# Проводится A/B-тестирование для двух вариантов дизайна сайта. Результаты тестирования собраны в двух файлах 
# (данные для группы А и для группы B).

# Каждая таблица имеет следующие поля:
# 
# date — дата наблюдения
# cid — идентификатор посетителя;
# transactions — количество совершённых целевых действий (транзакций);
# revenue — сумма покупки;
# group — группа (тестовая — А, контрольная — B).
# 
# Используйте эти данные для ответа на следующие вопросы.

sample_a = pd.read_csv('data/ab_test-redesign_sample_a.csv')
sample_b = pd.read_csv('data/ab_test-redesign_sample_b.csv')

print(sample_b.head())
print(sample_a.head())

print(sample_b.info())
print(sample_a.info())

sample_a['date'] = pd.to_datetime(sample_a['date'], format='%Y-%m-%d')

sample_b['date'] = pd.to_datetime(sample_b['date'], format='%Y-%m-%d')

print(sample_b.info())
print(sample_a.info())

# объединяем таблицы

sample = pd.concat(
    [sample_a, sample_b],
    ignore_index=True
)
print(sample)

# Постройте таблицу со следующими ежедневными показателями:
# количество посетителей сайта;
# суммарное число транзакций;
# общая сумма покупок (выручка).
# Для этого сгруппируйте данные по признаку date, предварительно преобразовав его к типу datetime.
# Чему равны значения ежедневных показателей в группе А на 8 ноября 2020 года?

sample_1 = sample.groupby(['date','group']).agg({
    'cid':'count',
    'transactions':'sum',
    'revenue' : 'sum'
}).reset_index().rename(columns={'cid': 'users_count'})

print(sample_1.head())

# Количество посетителей сайта:
print(sample_1[(sample_1['date'] == '2020-11-08') & (sample_1['group'] == 'A')]['users_count'])

# Суммарное число транзакций:
print(sample_1[(sample_1['date'] == '2020-11-08') & (sample_1['group'] == 'A')]['transactions'])

# Общая сумма покупок:
print(sample_1[(sample_1['date'] == '2020-11-08') & (sample_1['group'] == 'A')]['revenue'])


# Добавьте в каждую из таблиц кумулятивные метрики:
# кумулятивное количество посетителей сайта;
# кумулятивное суммарное число транзакций;
# кумулятивная общая сумма покупок (кумулятивная выручка).
# 
# Рассчитайте кумулятивную конверсию действия покупки (в процентах) и кумулятивный средний чек 
# (кумулятивная выручка/кумулятивное суммарное число транзакций).
# 
# Чему равна средняя кумулятивная конверсия в группах за весь период проведения A/B-теста? 
# Ответ округлите до сотых, знаки процентов не вводите.

# кумулятивное количество посетителей сайта
sample_1['cum_users_count'] = sample_1.groupby(['group'])['users_count'].cumsum()

# кумулятивное суммарное число транзакций;

sample_1['cum_transactions'] = sample_1.groupby(['group'])['transactions'].cumsum()

# кумулятивная общая сумма покупок (кумулятивная выручка)

sample_1['cum_revenue'] = sample_1.groupby(['group'])['revenue'].cumsum()

# вычисляем конверсию действия покупки (в процентах)
sample_1['cum_conversion'] = sample_1['cum_transactions']/sample_1['cum_users_count'] * 100

# вычисляем кумулятивный средний чек (кумулятивная выручка/кумулятивное суммарное число транзакций)
sample_1['cum_average_check'] = sample_1['cum_revenue']/sample_1['cum_transactions'] * 100

# вычисляем среднюю кумулятивную конверсию в группах за весь период проведения A/B-теста? 
# Ответ округлите до сотых, знаки процентов не вводите

sample_1_conversion_piv = sample_1.groupby('group')['cum_conversion'].agg(
    ['mean', 'median']
)

print(sample_1_conversion_piv)

# Постройте графики кумулятивной конверсии в каждой группе. Какие выводы по ним вы можете сделать?

# создаём фигуру размером 8x4
fig = plt.figure(figsize=(8, 4))
# строим lineplot для кумулятивной конверсии во времени в каждой группе
lineplot = sns.lineplot(
    x='date', 
    y='cum_conversion', 
    data = sample_1, 
    hue='group'
    )
# задаём подпись к графику
lineplot.set_title('График кумулятивной конверсии по дням')
# задаём поворот меток на оси абсцисс
lineplot.xaxis.set_tick_params(rotation = 45)
# задаём отображение сетки
lineplot.grid(True)

plt.show()

# Постройте графики кумулятивного среднего чека в каждой группе. Какие выводы по ним вы можете сделать?

# создаём фигуру размером 8x4
fig = plt.figure(figsize=(8, 4))
# строим lineplot для кумулятивной конверсии во времени в каждой группе
lineplot = sns.lineplot(
    x='date', 
    y='cum_average_check', 
    data = sample_1, 
    hue='group'
    )
# задаём подпись к графику
lineplot.set_title('График кумулятивного среднего чека по дням')
# задаём поворот меток на оси абсцисс
lineplot.xaxis.set_tick_params(rotation = 45)
# задаём отображение сетки
lineplot.grid(True)

plt.show()


