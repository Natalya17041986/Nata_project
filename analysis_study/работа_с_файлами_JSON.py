import json

from pprint import pprint

with open('data/recipes.json') as f: # Открываем файл и связываем его с объектом "f"
    recipes = json.load(f) # Загружаем содержимое открытого файла в переменную recipes
    
# Отлично! Теперь содержимое нашего файла загружено в переменную recipes. Давайте выведем его на экран с
# помощью функции pprint() из одноимённого модуля:

# pprint(recipes) # Выводим на экран содержимое переменной recipes, используя функция pprint()


# Итак, мы видим, что рецепт каждого из блюд описан в виде словаря, который состоит из трёх пар "ключ-значение":
# Ключ "cuisine" — обозначает принадлежность блюда к определённой национальной кухне 
# (например, 'greek', 'southern_us', 'filipino' и т. д.)
# Ключ "id" — уникальный идентификационный номер блюда
# Ключ "ingredients"— содержит перечень продуктов, входящих в состав блюда

# После того как мы провели десериализацию данных из JSON-файла, мы можем работать с полученным объектом 
# как с обычными списками и словарями. Единственное отличие этой работы от манипуляций с привычными нам 
# списками и словарями заключается в том, что данных теперь больше и они помещены внутрь структуры с
# большим количеством уровней вложенности.
# Давайте выясним некоторые детали о блюде, которое записано первым в списке блюд. 
# Его индекс — 0, и информация о нём хранится в словаре. Чтобы узнать ID этого блюда, мы можем 
# обратиться к соответствующему ключу словаря, выполнив следующий код:

pprint(recipes[0]['id'])

# Здесь мы сначала извлекаем из списка первый элемент (индекс 0). 
# Поскольку каждый элемент списка является словарём, для получения нужной информации о конкретном блюде нам 
# нужно указать ключ словаря. ID блюда доступно по ключу 'id', и мы указываем этот ключ в отдельной паре 
# квадратных скобок 
# Аналогичным образом, для получения списка ингредиентов первого блюда в списке мы можем использовать 
# тот же код, заменив в нём ключ 'id' на 'ingredients'. 

# Сколько ингредиентов входят в состав первого блюда из предлагаемого списка?

pprint(len(recipes[0]['ingredients']))

# К какой кухне относится блюдо с id = 13121?

for recipe in recipes:
    if recipe['id'] == 13121:
        print(recipe['cuisine'])
        break
    
# Какое количество уникальных национальных кухонь присутствуют в нашем наборе данных?

# Решение при помощи списка
coisine_len = []

for cuisines in recipes:
    if not cuisines['cuisine'] in coisine_len:
        coisine_len.append(cuisines['cuisine'])
pprint(len(coisine_len))

# Решение при помощи множества

cuisines = set()  # создаём пустое множество для хранения уникальных значений кухонь
for recipe in recipes:  # начинаем перебор всех рецептов
    cuisines.add(recipe['cuisine']) # добавляем название типа кухни к множеству
len(cuisines) # Выводим на экран полученное значение

# Какой из национальных кухонь принадлежит самое большое количество рецептов?

for recipe in recipes: # Начинаем перебор всех рецептов
    if not(recipe['cuisine'] in cuisines): # Если тип кухни текущего блюда ещё не встречался
        cuisines.append(recipe['cuisine']) # Добавляем его к списку cuisines
valreccuisine = {} # Создаём пустой словарь для хранения информации об количествах рецептов в каждой кухне
for item in cuisines: # Перебираем список кухонь
    valreccuisine[item] = 0 # Добавляем в словарь ключ, соответствующий очередной кухне
for recipe in recipes: # Перебираем список рецептов
    valreccuisine[recipe['cuisine']] += 1 # Увеличиваем значение нужного ключа в словаре на 1

print(max(valreccuisine, key=valreccuisine.get)) # Извлекаем значения для всех ключей используя метод get(), 
# выбираем самое максимальное значение (при наличии одинаковых значений будет выбрано первое в словаре) и 
# выводим на экран ключ максимального значения

# Поскольку структура всех вложенных словарей одинакова, мы можем создать DataFrame на основе списка, 
# не проводя с ним никаких дополнительных манипуляций:

import pandas as pd
df = pd.DataFrame(recipes) # Создаём объект DataFrame из списка recipes
print(df.head()) # Выводим на экран первые строки полученного DataFrame

# Для непосредственного считывания содержимого файла recipes.json в переменную df 
# (объект DataFrame) используйте функцию read_json() (с англ. читать_json).

# df = pd.read_json('recipes.json') # Создаём объект DataFrame, загружая содержимое файла recipes.json
# print(df.head()) # Выводим на экран первые строки полученного DataFrame

# Работу над преобразованием DataFrame начнём с создания и заполнения столбцов, содержащих сведения о
# наличии или отсутствии каждого ингредиента в рецепте. Процесс заполнения выполним в два этапа:
# 1 Создадим функцию для заполнения значения в каждой ячейке. Функция будет проверять наличие конкретного 
# ингредиента в столбце ingredients для текущего блюда и возвращать 1, если ингредиент есть в рецепте, и 0, 
# если он отсутствует.
# 2 Организуем цикл, в котором будем перебирать наименования всех ингредиентов DataFrame 
# (для этого потребуется создать реестр, то есть некий список, который содержит уникальные наименования ингредиентов). 
# Для каждого ингредиента создадим в DataFrame столбец с соответствующим названием и заполним его единицами и нулями, 
# применив к DataFrame, а точнее к столбцу ingredients функцию, созданную нами на предыдущем этапе.

# Создайте реестр уникальных ингредиентов all_ingredients, который будет использоваться на втором этапе. 
# Какое количество уникальных ингредиентов в нашем DataFrame?


all_ingredients=set() # Создаем пустое множество для хранения реестра уникальных ингредиентов
for recipe in recipes: # Начинаем перебор всех блюд входящих в список
    for ingredient in recipe['ingredients']: # Начинаем перебор всех ингредиентов входящих в состав текущего блюда
        all_ingredients.add(ingredient ) # Добавляем уникальный ингредиент в реестр
print(len(all_ingredients)) # Выводим на экран количество уникальных ингредиентов из реестра

# Теперь определим функцию contains(), с помощью которой мы будем проверять наличие конкретного ингредиента 
# ingredient_name в рецепте текущего блюда, который представлен списком ingredient_list (значение в ячейке столбца 
# ingredients текущего рецепта).
# Функция будет возвращать 1, если ингредиент есть в рецепте, и 0, если он отсутствует:

def contains(ingredient_list): # Определяем имя функции и передаваемые аргументы
    if ingredient_name in ingredient_list: # Если ингредиент есть в текущем блюде,
        return 1 # возвращаем значение 1
    else: # Если ингредиента нет в текущем блюде,
        return 0 # возвращаем значение 0

# Отлично! Осталось лишь перебрать все ингредиенты из ранее созданного реестра all_ingredients с помощью цикла  
# for  и создать в DataFrame столбец с соответствующим названием, заполнив его единицами и нулями. 
# Для этого применим к DataFrame, а точнее, к столбцу ingredients функцию contains().

for ingredient_name in all_ingredients: # Последовательно перебираем ингредиенты в реестре all_ingredients
    df[ingredient_name] = df['ingredients'].apply(contains) 
    
# В DataFrame cоздаем столбец с именем текущего ингредиента и заполняем его единицами и нулями, используя 
# ранее созданную функцию contains

# В завершение изменим значение столбца ingredients — вместо списка ингредиентов в каждом рецепте 
# заполним столбец данными о количестве ингредиентов в нём:

df['ingredients'] = df['ingredients'].apply(len) # Заменяем список ингредиентов в рецепте на их количество 
print(df) # Выводим содержимое полученного DataFrame на экран

# Если мы планируем продолжать работать с DataFrame, созданными на основе данных, которые мы получили в 
# JSON-формате, то полезно будет сохранить промежуточный DataFrame в виде CSV-файла. 
# Для выполнения этой операции воспользуемся известной нам в Pandas функцией to_csv():

df.to_csv('data/recipes.csv', index = False)

# В качестве основного параметра мы указали имя файла, в котором необходимо сохранить данные.
# Также мы установили значение параметра index как False. Такая настройка позволит нам не сохранять индексы 
# строк в виде отдельного столбца; в результате не будут загружаться «лишние» данные при открытии файла 
# при помощи функции read_csv().

# Решим обратную задачу и создадим JSON-файл из сохранённого ранее CSV-файла, 
# который получили в конце предыдущего этапа. 
# Начнём с чтения файла и создания DataFrame на его основе:

df = pd.read_csv('data/recipes.csv') # Создаём DataFrame, читаем данные из файла в переменную df

ids = list(df['id'].unique())

ingredients=list(df.columns)[3:]

# Сейчас нам предстоит воссоздать эту структуру, извлекая данные из DataFrame. Для этого необходимо создать:
# пустой список new_recipes — для хранения итоговой структуры;
# используя код из Задачи 7.1, список ids — для хранения id всех блюд;
# используя код из Задачи 7.2, список ingredients — для хранения названий всех ингредиентов.
# Далее необходимо реализовать следующий алгоритм:
# Написать код функции make_list(), которая принимает на вход строку DataFrame df, содержащую полные
# данные об одном блюде, и возвращает перечень ингредиентов, входящих в состав этого блюда в виде списка
# Организовать цикл с параметром, в котором будут перебираться элементы списка ids. В результате в процессе 
# прохождения цикла параметр должен принять значение id каждого блюда.
# На каждом шаге цикла создать словарь, содержащий три пары "ключ-значение":
# ключу "id" присвоить текущее значение параметра цикла как целого числа;
# ключу "cuisine" присвоить значение соответствующей кухни, которое мы получим, применив фильтр 
# по текущему id к DataFrame df;
# ключу "ingredients" присвоить значение списка, воспользовавшись функцией make_list(), созданной на 
# первом шаге алгоритма.
# Каждый созданный словарь добавить к списку new_recipes:

def make_list(row): # Определяем имя функции и передаваемые аргументы
    ingredient_list=[] # Создаем пустой список ингредиентов текущего блюда
    for ingredient in ingredients: # Последовательно перебираем ингредиенты из реестра
        if row[ingredient].item()==1: # Если текущий ингредиент входит в состав текущего блюда
            ingredient_list.append(ingredient) # Добавляем ингредиент в список ингредиентов текущего блюда
    return ingredient_list # Возвращаем сформированный список ингредиентов

new_recipes = [] # Создаём пустой список для хранения итоговой структуры
for current_id in ids: # Организуем цикл с параметром current_id
    cuisine = df[df['id'] == current_id]['cuisine'].iloc[0] # Получаем значение соответствующей кухни, применив фильтр по текущему значению параметра цикла к DataFrame;
    current_ingredients = make_list(df[df['id'] == current_id]) # Получаем перечень ингредиентов, входящих в состав текущего блюда
    current_recipe = {'cuisine': cuisine, 'id': int(current_id), 'ingredients': current_ingredients} # Создаём текущий словарь
    new_recipes.append(current_recipe) # Добавляем созданный словарь к списку

# Осталось создать код функции  make_list(), выполнить сериализацию и записать результат в файл.



# Выполним сериализацию списка new_recipes и запишем полученные данные в файл.
# Для сериализации  используем функцию dumps(), которой в качестве параметра передадим список new_recipes. 
# Запись в файл осуществляется с помощью метода write(). Предварительно файл необходимо открыть для записи 
# с помощью функции open() c параметром 'w' (от англ. write, рус. писать):

import json # Импорт модуля json
new_recipes = json.dumps(new_recipes) # Функция dumps() модуля json сериализирует объект Python в строку формата JSON. 
with open('data/new_recipes.json', 'w') as write_file: # Откроем файл new_recipes.json для записи
    write_file.write(new_recipes) # Записываем содержимое подготовленные данные в файл