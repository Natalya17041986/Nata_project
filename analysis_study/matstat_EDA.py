import pandas as pd
import seaborn as sns

wine = pd.read_csv('data/wine_cleared.csv')

print(wine['points'].min()) # поиск минимального балла на вино

print(wine['price'].min()) # поиск минимальной цены за вино

import statistics

print(statistics.mean(wine['price'])) # вычисление средней стоимости одной бутылки вина

print(wine['price'].mean()) # вычисление средней стоимости одной бутылки вина стандартными методами

print(statistics.median(wine['price']))  # медиану стоимости бутылки вина

print(wine['price'].median())

# Также в библиотеке statistics есть функции, связанные с медианой, — функция statistics.median_low() и функция statistics.median_high().
# В случае, когда количество элементов в числовом ряду (серии) нечётное, функции возвращают то же, что и median().
# В случае, когда количество элементов чётное, у нас получается два средних значения:
# median_low() возвращает меньшее из них;
# median_high() возвращает большее из них.

# Примечание. Если в вашем наборе данных есть пропущенные значения, функции библиотеки statistics 
# в отличие от других методов (например np.median() из библиотеки numpy) будут автоматически игнорировать
# пропущенные значения, не выдавая ошибку.


print(statistics.mode(wine['price'])) # Вычислите моду стоимости бутылки (самую часто встречающуюся цену) вина


# Моду также можно вычислить при помощи statistics.multimode(). В случае наличия нескольких модовых 
# (популярных значений) функция statistics.mode() вернёт вам ошибку StatisticsError, 
# а statistics.multimode() — список с всеми вычисленными модовыми значениями.

print(wine['price'].mode())

# Для расчёта коэффициента корреляции применим функцию df.corr() библиотеки pandas.
# Вычислите коэффициент корреляции между переменными в датасете винных обзоров. 
# В ответ запишите величину коэффициента корреляции между ценой за бутылку и баллами за вино. 
# Округлите ответ до шести знаков после запятой.

print(wine.corr())

import matplotlib.pyplot as plt # библиотека визуализации
from scipy import stats # библиотека для расчетов

plt.subplot(1, 2, 1) # задаем сетку рисунка количество строк и столбцов
stats.probplot(wine['price'], plot=plt) # qq plot

plt.subplot(1, 2, 2) # располагаем второй рисунок рядом
plt.hist(wine['price']) # гистограмма распределения признака

plt.tight_layout() # чтобы графики не наезжали другу на друга, используем tight_layout
plt.show() # просмотр графика

plt.subplot(1, 2, 1) # задаем сетку рисунка количество строк и столбцов
stats.probplot(wine['points'], plot=plt) # qq plot

plt.subplot(1, 2, 2) # располагаем второй рисунок рядом
plt.hist(wine['points']) # гистограмма распределения признака

plt.tight_layout() # чтобы графики не наезжали другу на друга, используем tight_layout

plt.show() # просмотр графика

print(wine.corr(method = 'spearman')) # корреляция Спирмена


print(wine.corr(method = 'kendall')) # корреляция Кендалла

from sklearn.metrics import matthews_corrcoef


x = [+1, -1, +1, +1] # список значений признака х
y = [+1, +1, +1, -1] # список значений признака y

print(matthews_corrcoef(x, y)) # рассчитаем коэффициент корреляции Мэтьюса

## ВИЗУАЛИЗАЦИЯ КОРРЕЛЯЦИЙ


playboy = pd.read_csv('data/model.csv')

# Набор данных содержит ~600 записей о девушках и семь признаков
# BMI — индекс массы тела (ИМТ)
# year — год размещения модели в журнале
# waist — обхват талии модели
# hips — обхват бёдер модели
# height — рост модели
# weight — вес модели
# waist/hip — соотношение обхвата талии и бёдер

print(playboy.corr())

# ТЕПЛОВАЯ МАТРИЦА КОРРЕЛЯЦИЙ

import seaborn as sns

# Для построения тепловой матрицы корреляций мы воспользуемся методом sns.heatmap() библиотеки seaborn. 
# Метод принимает на вход двумерный массив данных под аргументом data. Это может быть матрица корреляций, 
# полученная методом df.corr(), матрица пропущенных значений, полученная методом df.isnull(), 
# набор данных и многое другое. 
# Передадим в метод heatmap() нашу матрицу корреляций corr():

sns.heatmap(playboy.corr(), annot = True)

plt.show()

# На горизонтальной и вертикальной осях располагаются названия признаков нашего датасета. 
# По главной диагонали — единицы. Матрица симметрична. Справа от матрицы располагается тепловая шкала коэффициентов 
# корреляции: от минимума -0.42 (это корреляция между признаками waist/hip + hips) и максимума по шкале — 1. 
# Такую тепловую матрицу очень удобно интерпретировать: в тёплых светлых оттенках отражена положительная 
# корреляция между признаками, в тёмных холодных — отрицательная корреляция. Например, самая большая отрицательная
# взаимосвязь составляет -0.42, а самая большая положительная — 0.74.

# Например, в нашем наборе данных мультиколлинеарность практически отсутствует, так как из материала прошлого 
# модуля мы знаем, что она возникает из-за признаков с сильной и очень сильной корреляцией. По шкале корреляций 
# это от 0.7 и выше; у нас есть такие признаки с корреляцией выше 0.7 (например: waist/hip + waist). 
# Коэффициент корреляции лишь немного выше, поэтому такой признак, скорее всего, не будет удалён из набора данных


# SCATTERPLOT

# Точечная диаграмма рассеивания — это такая диаграмма, в которой каждое значение, 
# которое принимает признак в датасете, отражено точкой.
# Подобная диаграмма помогает установить характер и силу связи признаков. 
# Присвоив каждой оси переменную, мы можем определить наличие связи между переменными. 
# Сила связи (коэффициент корреляции) зависит от того, насколько плотно расположены точки на диаграмме. 
# Например, на рисунке слева точки расположены более плотно, чем справа. Это означает большую силу связи. 

# Для построения точечной диаграммы рассеивания мы воспользуемся знакомой нам библиотекой seaborn, 
# которой мы пользовались при построении тепловой матрицы корреляции.
# Метод, который мы будем использовать, — sns.scatterplot(). Он отражает связь между переменными, 
# где есть аргументы метода x, y, и признаки, которые мы хотим исследовать.
# Возьмём для примера две пары признаков:
# по оси x="Waist/Hip" — соотношение обхвата талии/бедер, по оси y="Waist" — обхват талии;
# по оси x="Weight" — вес модели, а по оси y="Year" — год размещения модели в журнале.
# Построим для них точечную диаграмму:

sns.scatterplot(data=playboy, x="Waist/Hip", y="Waist")
plt.show()


# Где по оси x располагается признак Waist/Hip, а по оси y — признак Waist.
# 
# Построим диаграмму для следующей пары признаков и сравним их.

sns.scatterplot(data=playboy, x="Weight", y="Year")
plt.show()

# Сравнив эти два графика, мы можем сказать, что в первой паре признаков связь видна более отчётливо,
# точки больше прижаты друг к другу и выстроены визуально в линию. 
# Эта линия похожа на рассматриваемую нами в прошлом юните линейную связь.
# Во второй паре признаков они распределены по всему пространству — трудно выявить основную массу признаков, 
# связь кажется очень слабой.

# И если мы вернёмся к тепловой матрице корреляций, то увидим, что в первом случае корреляция составила 0.74, 
# а во втором -0.011 — очень слабая связь. Получается, что при помощи графиков мы можем оценить коэффициент 
# корреляции на глаз. 

# ГРАФИК ПОПАРНЫХ ОТНОШЕНИЙ PAIRPLOT

sns.pairplot(playboy)
plt.show()

# Структура похожа на изученную нами тепловую матрицу корреляций. На осях х и у расположились признаки из набора 
# данных. На главной диагонали вместо единиц представлены графики-распределения конкретной величины.
# В остальных ячейках мы можем увидеть точечный график связей признаков между собой — это scatterplot, 
# который мы строили для пары признаков. Здесь это пара признаков, которые пересекаются между собой.

print(playboy.corr())



print(playboy['Height'].mean())