# Разработаем код, так называемый скрипт (англ. script, рус. сценарий), — небольшую программу, 
# которая содержит последовательность действий для автоматического выполнения задачи.
# С помощью скрипта мы будем в удобном виде выгружать информацию по курсам валют с заранее выбранного сайта.

#Как только библиотека установлена, импортируем её и отправим наш первый запрос к ресурсу 
# Курсы валют ЦБ РФ в XML и JSON. Используем метод get() из библиотеки requests, 
# передав ему соответствующий URL —  https://www.cbr-xml-daily.ru/daily_json.js:

import requests # Импортируем библиотеку requests
url = 'https://www.cbr-xml-daily.ru/daily_json.js' # Определяем значение URL страницы для запроса
response = requests.get(url) # Делаем GET-запрос к ресурсу и результат ответа сохраняем в переменной response

print(response) # Выводим значение response на экран как объект

# Мы получили объект ответа Response, который содержит всю нужную нам информацию. По умолчанию 
# в квадратных скобках на экран выводится код статуса ответа. В данном случае 
# он равен 200 — то есть запрос был корректным и сервер отдал нам нужную информацию. 
# Значение кода статуса 404 означало бы, что страница по указанному адресу не найдена, 
# а значение 403 — что синтаксис GET-запроса неверный.

# Код ответа в виде числовой переменной можно получить с помощью метода status_code:

print(response.status_code) # Выводим числовое значение response на экран

# Вы уже импортировали модуль requests в ваш код. Напишите строку кода, при выполнении которой будет 
# сделан GET-запрос к ресурсу https://www.cbr-xml-daily.ru/daily.xml, а результат ответа будет сохранён 
# в переменной response

#url2 = 'https://www.cbr-xml-daily.ru/daily.xml'
#response = requests.get(url2)
#print(response)

#response = requests.get('https://www.cbr-xml-daily.ru/daily.xml')

# Мы сделали запрос и получили корректный ответ (код статуса — 200). Дальнейшую работу производим с результатом 
# запроса к ресурсу Курсы валют ЦБ РФ в XML и JSON.
# Как получить доступ ко всей информации, которую содержит ответ?
# Текст ответа хранится в атрибуте text. Выведем значение атрибута на экран и посмотрим на его содержимое:

print(response.text) # Выводим содержимое атрибута text переменной response на экран

# Как правило, при работе над реальным проектом на этапе получения данных мы уже понимаем, с какими 
# форматами данных нам придётся работать. На предлагаемом для работы ресурсе информация есть как в JSON-формате, 
# так и в XML. По нашему запросу ресурс возвращает информацию в JSON-формате, однако 
# в настоящий момент результат хранится как единая строка. Проверить тип данных полученного ответа можно,
# воспользовавшись функцией type().
# Для того чтобы удобно было работать с полученной информацией, нам необходимо преобразовать строку в словарь. 
# В объект ответа Response  из библиотеки requests уже встроен метод json() .
# Импортируем функцию pprint(), применим к полученному ответу метод json() и выведем полученный результат на экран:

from pprint import pprint # Импортируем функцию pprint()
currencies = response.json() # Применяем метод json()
pprint(currencies) # Выводим результат на экран)

# Теперь данные находятся в словаре и можно легко получать необходимые значения.
# Например, по ключу Valute мы можем обратиться к вложенному словарю, который содержит информацию о мировых валютах. 
# Выведем на экран, например, информацию о евро (EUR):

pprint(currencies['Valute']['EUR']) # Выводим на экран информацию о валюте евро

print(currencies['Valute']['CZK']['Name'])

# HTML позволяет создавать макет страницы, разбивая её на блоки: мы можем поместить содержимое посередине страницы, 
# сбоку и т. п.
# Кроме того, HTML используется для описания форматирования. Например, с его помощью мы можем указать, 
# какая часть текста должна отображаться крупным шрифтом как заголовок, какая — курсивом, а какая — как обычный текст.
# HTML является близким родственником уже знакомого вам формата XML. Разметка на языке HTML делается с помощью 
# так называемых тегов, которые помещаются в угловые скобки, и применяется к элементам, заключённым внутри них.
# Посмотрите на примеры:

# <h2> Это заголовок второго уровня </h2>
# <div> А это обычный текст </div>

# У корректной HTML-страницы есть заголовок и тело страницы. В заголовке (в тегах <head> … </head>)  размещается 
# техническая информация, подключаются скрипты и стили. В теле <body> … </body> находятся текст и данные, 
# которые непосредственно отображаются на странице в браузере.
# Разметка небольшой страницы выглядит примерно так:

#<!DOCTYPE html>
#<html lang="ru">
#    <head>
#        <title>Название страницы</title>
#       <meta charset="UTF-8">
#    </head>
#    <body>
#        <h1> Это заголовок страницы </h1>
#        <p> Какой-то текст </p>
#    </body>
#</html>


# Обратите внимание, что теги образуют иерархическую структуру, то есть одни теги расположены внутри других. 
# В примере выше тег <p> … </p> находится внутри тега <body> … </body>.
# Кроме того, у тегов могут быть атрибуты, которые пишутся внутри открывающегося тега. Самые популярные атрибуты — 
# это class и id:
# <h1 id="big-title"> Заголовок страницы </h1>
# <p class="red-back"> Какой-то текст </p>
# Изучение языка HTML находится вне рамок этого курса, но для того, чтобы собирать информацию с веб-страниц, 
# нет необходимости хорошо знать HTML. Достаточно понимать, что:
# существуют теги с разными именами;
# у тегов бывают атрибуты, такие как class и id;
# теги образуют иерархическую структуру, то есть одни теги вложены в другие.

# Получим HTML-код интересующей нас страницы.
# Для этого отправим GET-запрос с помощью библиотеки requests и метода get() и посмотрим на текст ответа 
# на наш запрос (как мы помним, он содержится в атрибуте text):

import requests # Импортируем библиотеку requests
url = 'https://nplus1.ru/news/2021/10/11/econobel2021' # Определяем адрес страницы
response = requests.get(url)  # Выполняем GET-запрос
print(response.text)  # Выводим содержимое атрибута text

# Ответ содержит HTML-код страницы, к которой мы обратились.
# В отличие от предыдущего примера, где ответ возвращался в JSON-формате, мы не можем так просто преобразовать 
# HTML-код в словарь и извлечь необходимую нам информацию.
# Для решения таких задач в Python существует специальная библиотека BeautifulSoup, о работе с которой мы поговорим 
# в следующем юните.

from bs4 import BeautifulSoup # Импортируем библиотеку BeautifulSoup

# Теперь мы можем извлекать данные из любой веб-страницы.
# Ранее мы уже получили содержимое страницы с помощью GET-запроса и сохранили информацию в переменной response , 
# теперь создадим объект BeautifulSoup с именем page, указывая в качестве параметра html.parser.
# Для примера получим информацию o title (с англ. заголовок) — это строка, которая отображается на вкладке браузера:

url = 'https://nplus1.ru/news/2021/10/11/econobel2021' # Определяем адрес страницы
response = requests.get(url) # Выполняем GET-запрос, содержимое ответа присваивается переменной response
page = BeautifulSoup(response.text, 'html.parser') # Создаём объект BeautifulSoup, указывая html-парсер
print(page.title) # Получаем тег title, отображающийся на вкладке браузера
print(page.title.text) # Выводим текст из полученного тега, который содержится в атрибуте text

# Выполним поставленную ранее задачу: получить информацию о странице и извлечь заголовок статьи, 
# опубликованной на этой странице, дату публикации, а также текст статьи.
# Предположим, что мы знаем, что в HTML-коде рассматриваемой нами страницы заголовок статьи заключён 
# в тег <h1> … </h1> (заголовок первого уровня).
# Тогда мы можем получить его текст с помощью метода find() (с англ. найти) объекта BeautifulSoup, 
# передав ему название интересующего нас тега:

print(page.find('title').text) # Применяем метод find() к объекту и выводим результат на экран

# Итак, нам нужен тег <time> … </time>.
# Теперь получим данные из него с помощью уже известного метода find(), передав название нужного тега:

print(page.find('time').text) # Выводим на экран содержимое атрибута text тега time

# Напишите функцию wiki_header, которая по адресу страницы возвращает заголовок для статей на Wikipedia.

# url = 'https://en.wikipedia.org/wiki/Operating_system'

# def wiki_header(url):
 #   page = BeautifulSoup(requests.get(url).text,'html.parser')
 #   head = (page.find('h1').text)
 #   return head

# Теперь получим сам текст статьи. Как вы уже знаете, первым делом необходимо определить,
# в какой тег он заключён. Применим, как и ранее, инструмент разработчика.
# Видим, что искомый текст заключён в тег  <div> … </div> . Попробуем извлечь его уже известным нам способом — 
# с помощью метода find() — и выведем его на экран.

print(page.find('div').text) # Выводим содержимое атрибута text тега div

# Мы увидели не то, что ожидали — пустое содержимое...
# В чём же проблема?
# Дело в том, что теги <div> … </div> очень распространённые и на странице их очень много. Метод find() 
# нашёл первый из них, но это не то, что нам надо.
# Посмотрим на нашу страницу, используя инструмент разработчика, ещё раз. Можем заметить, что у 
# искомого текста есть свой класс — body js-mediator-article :
# Передадим название класса в метод find() с помощью аргумента class_ и получим текст статьи:

print(page.find('div', class_='body').text) # Выводим содержимое атрибута text тега div класса body js-mediator-article

# В данном случае происходит поиск точного строкового значения class атрибута, т. е. выполнение строк кода:

print(page.find('div', class_='body').text)
print(page.find('div', class_='js-mediator-article').text)
print(page.find('div', class_='body js-mediator-article').text)

# даст одинаковый результат.

# При выполнении строки кода

# print(page.find('div', class_='js-mediator-article body').text)

# мы получим ошибку, так как такого строкового значения в области поиска нет


# Рассмотрим ещё один сценарий: вы хотите собрать сразу несколько элементов со страницы. Например, 
# представьте, что вы хотите получить названия всех языков программирования, упомянутых на странице в Wikipedia
# в статье про языки программирования.
# Можно заметить, что все названия языков программирования на этой странице связаны ссылками c соответствующими 
# статьями о них. Таким образом, нам необходимо собрать все ссылки на странице. Для ссылок в HTML предусмотрен 
# тег <a> … </a>. Попробуем использовать find():

url = 'https://en.wikipedia.org/wiki/List_of_programming_languages' # Задаём адрес ресурса
response = requests.get(url) # Делаем GET-запрос к ресурсу
page = BeautifulSoup(response.text, 'html.parser') # Создаём объект BeautifulSoup
print(page.find('a')) # Ищем ссылку по тегу <a> и выводим её на экран

# Мы получили только одну ссылку, хотя на странице их явно больше.
# Это происходит, потому что метод find() возвращает только первый подходящий элемент. Если требуется получить 
# больше элементов, необходимо воспользоваться методом find_all() (с англ. найти все):

links = page.find_all('a') # Ищем все ссылки на странице и сохраняем в переменной links в виде списка
print(len(links)) # Выводим количество найденных ссылок

# Итак, на момент создания этих учебных материалов на странице содержалось 928 ссылок. Посмотрим на некоторые из них:

print([link.text for link in links[500:510]]) # Выводим ссылки с 500 по 509 включительно

# Не все ссылки соответствуют названиям языков программирования — страница содержит также «служебные» ссылки, 
# такие, например, как Jump to navigation (с англ. Перейти к навигации) или Alphabetical (с англ. По алфавиту):

print([link.text for link in links[0:10]]) # Выводим ссылки с 1 по 9 включительно

# Для обработки полученных данных и исключения «лишней» информации можно, 
# например, использовать подходы, которые вы изучили в модуле PYTHON-14 - очистка данных

# ЗАПРОС К API ИЗ КОДА
# Продолжаем пользоваться всё той же библиотекой requests.

import requests # Импортируем модуль requests
token = 'c2e7dd9ec2e7dd9ec2e7dd9e38c29c6794cc2e7c2e7dd9ea0d1d7c6c3f34a82322e6fea' # Указываем свой сервисный токен
url = 'https://api.vk.com/method/users.get' # Указываем адрес страницы к которой делаем запрос
params = {'user_id': 1, 'v': 5.95, 'fields': 'sex,bdate', 'access_token': token, 'lang': 'ru'} # Перечисляем параметры нашего запроса в словаре params
response = requests.get(url, params=params) # Отправляем запрос
print(response.text) # Выводим текст ответа на экран

# Мы получили строку в JSON-формате, которую можно преобразовать в словарь с помощью метода json(), 
# после чего можно с лёгкостью обращаться к различным полям.
# Словари нагляднее выводить с помощью функции pprint(), которую мы уже использовали ранее:

from pprint import pprint # Импортируем функцию pprint()
pprint(response.json()) # Выводим содержимое словаря, содержащего ответ, на экран

# Как вы видите, по ключу response мы можем получить список, в котором хранятся словари, содержащие 
# информацию о запрошенных нами пользователях. Мы запросили информацию лишь об одном из них, поэтому 
# список содержит только один элемент. Извлечём его:

user = response.json()['response'][0] # Извлекаем из словаря по ключу response информацию о первом пользователе
print(user['bdate']) # Выводим дату рождения первого пользователя на экран

print(user['first_name'])

# Метод users.get() позволяет запрашивать информацию о множестве (до 1 000) пользователей одновременно. 
# Для этого нужно использовать параметр user_ids и передавать id через запятую в строковом формате. 
# Например, чтобы получить информацию о пользователях с id=1, id=2, id=3, необходимо передать значение 
# параметра user_ids='1,2,3'.
# Попробуем это сделать:

ids = ",".join(map(str, range(1, 4))) # Формируем строку, содержащую информацию о поле id первых трёх пользователей
params = {'user_ids': ids, 'v': 5.95, 'fields': 'bday', 'access_token': token, 'lang': 'ru'} 
# Формируем строку параметров
pprint(requests.get(url, params=params).json()) 
# Посылаем запрос, полученный ответ в формате JSON-строки преобразуем в словарь и выводим на экран 
# его содержимое, используя функцию pprint()

# Используя API, определите долю женщин (sex=1) среди пользователей с id от 1 до 500. Иногда будут попадаться 
# пользователи, у которых пол не указан (sex=0), — таких пользователей не нужно учитывать в общем числе.
# В ответе укажите число, округлив до двух знаков после точки-разделителя, например, 0.55.
# Пример: если у нас будет 300 пользователей с sex=1, 100 пользователей с sex=2 и 100 пользователей с sex=0, 
# то в ответе должно быть 0.75.

ids = ",".join(map(str, range(1, 501)))
params = {'user_ids': ids, 'v': 5.95, 'fields': 'sex,bdate', 'access_token': token, 'lang': 'ru'}
response = requests.get(url, params=params).json()['response']
men=women=0
for elem in response:
    if elem['sex'] == 2:
        men+=1
    elif elem['sex'] == 1:
        women+=1
    else:
        continue
print(round(women/(men+women),2))


# Давайте рассмотрим, как работать с этими ограничениями на примере выгрузки списка пользователей 
# группы https://vk.com/vk социальной сети ВКонтакте.
# Обратимся к документации, чтобы узнать, какие методы нам доступны для групп, — для получения списка 
# пользователей группы доступен метод groups.getMembers.
# Согласно документации, обязательным параметром данного метода является group_id — идентификатор, 
# или короткое имя, группы. В нашем случае это vk: https://vk.com/vk. Протестируем, как работает метод в 
# самом простом случае, — получим id участников группы:

import requests # Импортируем модуль requests
token = 'c2e7dd9ec2e7dd9ec2e7dd9e38c29c6794cc2e7c2e7dd9ea0d1d7c6c3f34a82322e6fea' # Указываем свой сервисный токен
url = 'https://api.vk.com/method/groups.getMembers' # Указываем адрес обращения
params = {'group_id': 'vk', 'v': 5.95, 'access_token': token} # Формируем строку параметров
response = requests.get(url, params = params) # Посылаем запрос
data = response.json() # Ответ сохраняем в переменной data в формате словаря
print(data) # Выводим содержимое переменной data на экран (отображён фрагмент)

# По ключу count мы можем получить общее число участников группы, а список по ключу items хранит их id.
# Посмотрим на него поближе:

print(len(data['response']['items'])) # Выводим на экран количество элементов словаря

# Мы видим, что всего пользователей в группе больше 11 миллионов, а получили мы только первую тысячу пользователей 
# группы. По информации, указанной в документации о параметре count, это максимум, который может отдать API за один раз.
# Для получения следующей тысячи пользователей можно воспользоваться параметром offset (с англ. смещение), 
# который передвинет начало отсчёта. Для выгрузки всех пользователей группы будем в цикле выгружать 
# по 1000 пользователей (count будет всегда равен 1000), увеличивая смещение offset на величину count.
# Для тренировки напишем цикл выгрузки первых 20 пользователей со значением count=5. Иными словами, мы будем 
# выгружать по пять пользователей за запрос до тех пор, пока не получим информацию о 20 пользователях.
# Давайте выведем на экран первые 20 пользователей из нашей первой попытки получить информацию о 1000 пользователей, 
# чтобы мы могли сверить результат выгрузки из 20 пользователей:

users_for_checking = data['response']['items'][:20] 
# Загружаем в переменную информацию об id первых 20 пользователей в виде списка
print(users_for_checking) # Выводим перечень id первых 20 пользователей

# Теперь используем count и offset, чтобы получить те же id по пять за раз:

import requests # Импортируем модуль requests
token = 'c2e7dd9ec2e7dd9ec2e7dd9e38c29c6794cc2e7c2e7dd9ea0d1d7c6c3f34a82322e6fea' # Указываем свой сервисный токен
url = 'https://api.vk.com/method/groups.getMembers' # Указываем адрес обращения
count = 5 
offset = 0 
user_ids = [] 
max_count = 20 
while offset < max_count: 
    # Будем выгружать по count=5 пользователей, 
    # начиная с того места, где закончили на предыдущей итерации (offset) 
    print('Выгружаю {} пользователей с offset = {}'.format(count, offset))   
    params = {'group_id': 'vk', 'v': 5.95, 'count': count, 'offset': offset, 'access_token': token} 
    response = requests.get(url, params = params) 
    data = response.json() 
    user_ids += data['response']['items'] 
    # Увеличиваем смещение на количество строк, которое мы уже выгрузили 
    offset += count 
print(user_ids) 

# Сравним списки, полученные двумя способами:

print(user_ids == users_for_checking) 

# Так как результат сравнения — True, списки идентичны. Значит, второй способ работает корректно. 
# Теперь мы можем получить данные обо всех пользователях, выставив 
# count = 1000 и max_count = data['response']['count'].

# В API часто добавляют ограничение по частоте запросов, чтобы отдельно взятые пользователи слишком сильно 
# не перегружали сервер. Подобное ограничение есть и у ВКонтакте — в документации указано, 
# что можно делать не более трёх запросов в секунду.
# Чтобы не следить за частотой отправки запросов с секундомером в руках, мы можем после каждого запроса делать паузу.
# В этом случае, даже если код будет выполняться на самом быстром компьютере, мы не нарушим установленное 
# ограничение, так как периодичность отправки запросов будет искусственно замедлена.
# Воспользуемся библиотекой time и методом sleep, с помощью которого мы можем добавить паузу, например в 0.5 
# секунд, после каждого запроса:

import requests # Импортируем модуль requests
import time # Импортируем модуль time
token = 'c2e7dd9ec2e7dd9ec2e7dd9e38c29c6794cc2e7c2e7dd9ea0d1d7c6c3f34a82322e6fea' # Указываем свой сервисный токен
url = 'https://api.vk.com/method/groups.getMembers' # Указываем адрес страницы, к которой делаем запрос
count = 1000 
offset = 0  
user_ids = []  
while offset < 5000: 
    params = {'group_id': 'vk', 'v': 5.95, 'count': count, 'offset': offset, 'access_token': token} 
    response = requests.get(url, params = params) 
    data = response.json() 
    user_ids += data['response']['items'] 
    offset += count 
    print('Ожидаю 0.5 секунды...') 
    time.sleep(0.5) 
print('Цикл завершен, offset =',offset) 

# Через API новостной ленты ВКонтакте мы можем получить информацию о взаимодействии с сообщениями в ленте.
# Для примера продолжим работать с группой https://vk.com/vk и рассмотрим последние 1000 сообщений в новостной ленте.
# Для получения информации о сообщениях на стене в API ВКонтакте предусмотрен метод wall.get. Применим его:

import requests # Импортируем модуль requests
from pprint import pprint # Импортируем функцию pprint()
token = 'c2e7dd9ec2e7dd9ec2e7dd9e38c29c6794cc2e7c2e7dd9ea0d1d7c6c3f34a82322e6fea' # Указываем свой сервисный токен
url = 'https://api.vk.com/method/wall.get' # Указываем адрес страницы, к которой делаем запрос
params = {'domain': 'vk', 'filter': 'owner', 'count': 1000, 'offset': 0, 'access_token': token, 'v': 5.95} 
response = requests.get(url, params = params) 
pprint(response.json()) 

# Анализируя ответ, понимаем, что по ключу count можно найти общее количество сообщений в новостной ленте, 
# а по ключу items — сами сообщения.
# Посмотрим на информацию об отдельном сообщении:

print(response.json()['response']['items'][0])

# В полях comments, likes и reposts содержится статистика по взаимодействию с сообщением пользователей 
# (на момент получения информации) — число комментариев, лайков и репостов.

# Давайте соберём итоговую статистику для последних десяти непустых сообщений в словарь stats. 
# В качестве ключа будем использовать начало сообщения (если начало сообщения пустое, то информацию о таком 
# сообщении проигнорируем), в качестве значения — список с тремя интересующими нас метриками и временем публикации
# (комментарии, лайки, репосты, дата публикации):

stats = {} 
count_post = 0 # Счётчик «непустых» сообщений
for record in response.json()['response']['items'][:]:
    title = record['text'][:30] 
    if title: 
        stats[title] = [record['comments']['count'], record['likes']['count'], record['reposts']['count'], record['date']] 
        count_post += 1 
    if count_post < 10: 
        continue 
    else: 
        break 
pprint(stats)

# Итак, на момент создания учебных материалов десять последних непустых сообщений в группе имели следующую статистику:

# Мы рассмотрели базовое взаимодействие с пользователями и группами. ВКонтакте предоставляет 
# достаточно широкие возможности в своём API: всё, что можно делать вручную через браузер, доступно и в API.


 ## РАБОТА СО СКРИПТАМИ 
 
import schedule # Импортируем модуль schedule

# Рассмотрим вариант автоматического запуска простой функции, которая выводит на экран короткое сообщение:

def task(): 
    print('Hello! I am a task!') 
    return

# Предположим, что мы хотим, чтобы функция запускалась через определённые интервалы времени, а именно каждые 15 минут.
# Для запуска задачи через определённые интервалы времени в модуле schedule используется метод every(), 
# который получает в качестве единственного аргумента число, указывающее, как часто следует запускать код.
# Далее вызывается метод, определяющий единицы измерения промежутков времени, через которые будет выполняться 
# функция. В нашем примере это минуты. Вот как будет выглядеть итоговый код:

schedule.every(15).minutes.do(task)

# Если бы мы хотели запускать задачу, например, каждый час, то могли бы написать:
# schedule.every(1).hour.do(task) 

# После того как мы создали нашу функцию и определились со временем её запуска, мы можем запустить наш 
# менеджер расписания (schedule). Для этого надо создать бесконечный цикл. Да-да, именно так, ведь скрипт должен 
# выполняться постоянно, чтобы постоянно проверять, не пришло ли время снова выполнить задачу.
# Внутри цикла мы будем вызывать особый метод run_pending() для объекта schedule, который будет проверять, 
# нет ли задачи, которую пора выполнить.
# После вызова метода run_pending() нужно будет сделать небольшую паузу, после которой можно будет снова 
# проверять, не пришло ли время для выполнения какой-либо функции.
# Давайте напишем этот код.
# Для создания паузы мы будем использовать метод sleep из модуля time, поэтому наш код начнётся с импорта данного 
# модуля:

import time 
while True: 
    schedule.run_pending() 
    time.sleep(1) 
# Всё готово — теперь можно сохранить файл и выполнить код.

# Вот какой код в итоге получился:

import schedule

def task(): 
    print('Hello! I am a task!') 
    return

schedule.every(15).minutes.do(task)

import time 
while True: 
    schedule.run_pending() 
    time.sleep(1)

# Этот код будет каждую секунду проверять, не надо ли выполнить какую-то задачу, и раз в 15 минут будет выводить 
# на экран фразу: "Hello! I am a task!" Вывод сообщения будет повторяться до тех пор, пока вы не остановите 
# выполнение скрипта.

