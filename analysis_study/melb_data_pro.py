import pandas as pd

melb_data = pd.read_csv('data/melb_data_ps.csv', sep=',')
print(melb_data.head())

#создание копии таблицы:

melb_df = melb_data.copy()
print(melb_df.head())

#Удалим столбцы index и Coordinates из таблицы и выведем первые пять строк таблицы и убедимся, что всё прошло успешно

melb_df = melb_df.drop(['index', 'Coordinates'], axis=1)
print(melb_df.head())

# альтернативный вариант:


# Например, давайте создадим переменную total_rooms, 
# в которой будем хранить общее количество комнат в здании. 
# Для этого выполним сложение столбцов с количеством комнат, ванн и спален:
total_rooms = melb_df['Rooms'] + melb_df['Bedroom'] + melb_df['Bathroom']
print(total_rooms)

# А теперь введём признак MeanRoomsSquare, который соответствует средней площади одной комнаты для каждого объекта. 
# Для этого разделим площадь здания на полученное ранее общее количество комнат
melb_df['MeanRoomsSquare'] = melb_df['BuildingArea'] / total_rooms
print((melb_df['MeanRoomsSquare']))

#Можно ввести ещё один интересный признак — AreaRatio, 
# коэффициент соотношения площади здания (BuildingArea) и площади участка (Landsize). 
# Для этого разницу двух площадей поделим на их сумму
diff_area = melb_df['BuildingArea'] - melb_df['Landsize']
sum_area = melb_df['BuildingArea'] + melb_df['Landsize']
melb_df['AreaRatio'] = diff_area/sum_area
print(melb_df['AreaRatio'])

#Для того чтобы преобразовывать столбцы с датами, записанными в распространённых форматах, 
# в формат datetime, можно воспользоваться функцией pandas.to_datetime(). 
# Преобразуем столбец Date в формат datetime, передав его в эту функцию:
melb_df['Date'] = pd.to_datetime(melb_df['Date'])
print(melb_df['Date'])

# Например, обратившись по атрибуту dt.year в столбце Date, 
# мы можем «достать» год продажи и понять, за какой интервал времени (в годах) представлены наши данные, 
# а также на какой год приходится наибольшее число продаж:
years_sold = melb_df['Date'].dt.year
print(years_sold)
print('Min year sold:', years_sold.min())
print('Max year sold:', years_sold.max())
print('Mode year sold:', years_sold.mode()[0])
#В результате обращения к атрибуту datetime melb_df['Date'].dt.year мы получаем объект Series, 
# в котором в качестве значений выступают годы продажи объектов недвижимости. 
# Мы можем занести результат в переменную year_sold и далее работать с ней как с обычным столбцом Series — 
# вычислять максимум, минимум и модальное значение.
#Примечание. Так как модальных значений в столбце может быть несколько, метод mode() возвращает объект Series, 
# даже если мода в данных только одна. Чтобы сохранить стилистику вывода информации о годе продажи и выводить только число, 
# а не Series, мы обращаемся к результату работы метода mode() по индексу 0.

#Теперь попробуем понять, на какие месяцы приходится пик продаж объектов недвижимости. 
# Для этого выделим атрибут dt.month и на этот раз занесём результат в столбец MonthSale, 
# а затем найдём относительную частоту продаж для каждого месяца от общего количества продаж — 
# для этого используем метод value_counts() с параметром normalize (вывод в долях):
melb_df['MonthSale'] = melb_df['Date'].dt.month
print(melb_df['MonthSale'].value_counts(normalize=True))

#Часто бывает такая ситуация, что необходимо вычислять интервалы между двумя временными промежутками. 
# Например, можно вычислить, сколько дней прошло с 1 января 2016 года до момента продажи объекта. 
# Для этого можно просто найти разницу между датами продаж и заявленной датой, представленной в формате datetime:
delta_days = melb_df['Date'] - pd.to_datetime('2016-01-01') 
print(delta_days)

#Чтобы превратить количество дней из формата интервала в формат целого числа дней, 
# можно воспользоваться аксессором dt для формата timedelta и извлечь из него атрибут days:
print(delta_days.dt.days)

#Давайте создадим признак возраста объекта недвижимости в годах на момент продажи. 
# Для этого выделим из столбца с датой продажи год и вычтем из него год постройки здания. 
# Результат оформим в виде столбца AgeBuilding:
melb_df['AgeBuilding'] = melb_df['Date'].dt.year - melb_df['YearBuilt']
print(melb_df['AgeBuilding'])
#Обратите внимание, что, так как года кодируются целым числом, 
# в результате мы тоже получаем целочисленный столбец — тип int64 (а не timedelta).

#На самом деле столбец AgeBuilding дублирует информацию столбца YearBuilt, т
# ак как, зная год постройки здания, мы автоматически знаем его возраст. Такие признаки не стоит оставлять вместе, 
# поэтому оставим возраст здания, так как он является более наглядным, а год постройки удалим из таблицы:
melb_df = melb_df.drop('YearBuilt', axis=1)

#Создайте в таблице melb_df признак WeekdaySale (день недели). 
# Найдите, сколько объектов недвижимости было продано в выходные (суббота и воскресенье), 
# результат занесите в переменную weekend_count. В качестве ответа введите результат вывода переменной weekend_count.
melb_df['WeekdaySale'] = melb_df['Date'].dt.dayofweek
weekend_count = melb_df[(melb_df['WeekdaySale'] == 5) | (melb_df['WeekdaySale'] == 6)].shape[0]
print(weekend_count)

#В наших данных есть столбец с адресами объектов недвижимости. 
# Проблема этого столбца в том, что в нём слишком большое количество уникальных значений: 
# почти на каждый объект недвижимости в таблице приходится свой уникальный адрес. 
# Убедимся в этом, вычислив количество уникальных значений в столбце с помощью метода nunique():
print(melb_df['Address'].nunique())

#Обычно подобные признаки удаляют, однако можно поступить умнее: давайте извлечём из признака адреса характеристику подвида улицы 
# (улица, шоссе, авеню, бульвар). Для этого сначала внимательнее посмотрим на структуру адреса, выберем несколько строк столбца Address:
print(melb_df['Address'].loc[177])
print(melb_df['Address'].loc[1812])
print(melb_df['Address'].loc[9001])
#Итак, адрес строится следующим образом: сначала указывается номер дома и корпус, после указывается название улицы, 
# а в конце — подтип улицы, но в некоторых случаях к подтипу добавляется географическая отметка 
# (N — север, S — юг и т. д.), она нам не нужна . Для того чтобы выделить подтип улицы, на которой находится объект, 
# можно использовать следующую функцию:
# На вход данной функции поступает строка с адресом.
def get_street_type(address):
# Создаём список географических пометок exclude_list.
    exclude_list = ['N', 'S', 'W', 'E']
# Метод split() разбивает строку на слова по пробелу.
# В результате получаем список слов в строке и заносим его в переменную address_list.
    address_list = address.split(' ')
# Обрезаем список, оставляя в нём только последний элемент,
# потенциальный подтип улицы, и заносим в переменную street_type.
    street_type = address_list[-1]
# Делаем проверку на то, что полученный подтип является географической пометкой.
# Для этого проверяем его на наличие в списке exclude_list.
    if street_type in exclude_list:
# Если переменная street_type является географической пометкой,
# переопределяем её на второй элемент с конца списка address_list.
        street_type = address_list[-2]
# Возвращаем переменную street_type, в которой хранится подтип улицы.
    return street_type

#Теперь применим эту функцию к столбцу c адресом. Для этого передадим функцию get_street_type в аргумент метода столбца apply(). 
# В результате получим объект Series, который положим в переменную street_types:
street_types = melb_df['Address'].apply(get_street_type)
print(street_types)

#Итак, мы смогли выделить подтип улицы. Посмотрим, сколько уникальных значений у нас получилось:
print(street_types.nunique())

#У нас есть 56 уникальных значений. Однако наш результат можно улучшить. 
# Давайте для начала посмотрим на частоту каждого подтипа улицы с помощью метода value_counts:
print(street_types.value_counts())

 # В таком случае давайте применим очень распространённый метод уменьшения количества уникальных категорий — 
 # выделим n подтипов, которые встречаются чаще всего, а остальные обозначим как 'other' (другие).
 # Для этого к результату метода value_counts применим метод nlargest(), который возвращает n наибольших значений из Series. 
 # Зададим n=10, т. е. мы хотим отобрать десять наиболее популярных подтипов. Извлечём их названия с помощью атрибута index, 
 # а результат занесём в переменную popular_stypes:
popular_stypes =street_types.value_counts().nlargest(10).index
print(popular_stypes)

#Теперь, когда у нас есть список наиболее популярных подтипов улиц, введём lambda-функцию, которая будет проверять, 
# есть ли строка x в этом перечне, и, если это так, lambda-функция будет возвращать x, 
# в противном случае она будет возвращать строку 'other'. Наконец, применим такую функцию к 
# Series street_types, полученной ранее, а результат определим в новый столбец таблицы StreetType:
melb_df['StreetType'] = street_types.apply(lambda x: x if x in popular_stypes else 'other')
print(melb_df['StreetType'])

#Посмотрим на результирующее число уникальных подтипов:
print(melb_df['StreetType'].nunique())

#Теперь, у нас нет потребности хранить признак Address, так как, если конкретное местоположение объекта всё же и влияет на его стоимость, 
# то оно определяется столбцами Longitude и Lattitude. Удалим его из нашей таблицы:
melb_df = melb_df.drop('Address', axis=1)

#Ранее, в задании 3.3, мы создали признак WeekdaySale в таблице melb_df — день недели продажи. 
# Из полученных в задании результатов можно сделать вывод, что объекты недвижимости в Мельбурне 
# продаются преимущественно по выходным (суббота и воскресенье).
# Напишите функцию get_weekend(weekday), которая принимает на вход элемент столбца WeekdaySale и 
# возвращает 1, если день является выходным, 
# и 0 — в противном случае, и создайте столбец Weekend в таблице melb_df с помощью неё.
def get_weekend(weekday):
    if weekday == 5 or weekday == 6:
        return 1
    else: 
        return 0
melb_df['Weekend'] = melb_df['WeekdaySale'].apply(get_weekend)
print(round(melb_df[melb_df['Weekend']==1]['Price'].mean(), 2))

#Преобразуйте столбец SellerG с наименованиями риелторских компаний в таблице melb_df следующим образом: 
# оставьте в столбце только 49 самых популярных компаний, а остальные обозначьте как 'other'. 
# Найдите, во сколько раз минимальная цена объектов недвижимости, проданных компанией 'Nelson', 
# больше минимальной цены объектов, проданных компаниями, обозначенными как 'other'. Ответ округлите до десятых.
popular_seler = melb_df['SellerG'].value_counts().nlargest(49).index
# заменяем значения улиц, не попавших в список популярных на строку 'other'
melb_df['SellerG'] = melb_df['SellerG'].apply(lambda x: x if x in popular_seler else 'other') 

a = melb_df[melb_df['SellerG'] == 'Nelson']['Price'].min() 
b = melb_df[melb_df['SellerG'] == 'other']['Price'].min() 
print(round(a/b, 1))
