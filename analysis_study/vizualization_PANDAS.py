import pandas as pd

covid_data = pd.read_csv('data/covid_data.csv')
print(covid_data.head())

# Мы будем работать со следующими столбцами:
# date — дата наблюдения
# province/state — наименование провинции/штата;
# country — наименование страны;
# confirmed — общее число зафиксированных случаев на указанный день;
# deaths — общее число зафиксированных смертей на указанный день;
# recovered — общее число выздоровлений на указанный день.

vaccinations_data = pd.read_csv('data/country_vaccinations.csv')
vaccinations_data = vaccinations_data[
    ['country', 'date', 'total_vaccinations', 
     'people_vaccinated', 'people_vaccinated_per_hundred',
     'people_fully_vaccinated', 'people_fully_vaccinated_per_hundred',
     'daily_vaccinations', 'vaccines']
]

#Данная таблица содержит следующие столбцы:
# country — наименование страны;
# date — дата наблюдения;
# total_vaccinations — общее число введённых вакцин в стране на указанный день;
# people_vaccinated — общее число привитых первым компонентом в стране на указанный день;
# people_vaccinated_per_hundred — процент привитых первым компонентом в стране на указанный день (рассчитывается как );
# people_fully_vaccinated — общее число привитых вторым компонентом в стране на указанный день (первый компонент уже был введён им ранее);
# people_fully_vaccinated_per_hundred — процент привитых вторым компонентом в стране на указанный день (рассчитывается как );
# daily_vaccination — ежедневная вакцинация (число вакцинированных в указанный день);
# vaccines — комбинации вакцин, используемые в стране.

# В таблице covid_data:
# 1 Группируем таблицу по дате и названию страны и рассчитываем суммарные показатели по всем регионам. Тем самым переходим от данных по регионам к данным по странам:

covid_data = covid_data.groupby(
    ['date', 'country'], 
    as_index=False
)[['confirmed', 'deaths', 'recovered']].sum()

# 2 Преобразуем даты в формат datetime с помощью функции pd.to_datetime():

covid_data['date'] = pd.to_datetime(covid_data['date'])

# 3 Создадим признак больных на данный момент (active). Для этого вычтем из общего числа зафиксированных случаев число смертей и число выздоровевших пациентов:

covid_data['active'] = covid_data['confirmed'] - covid_data['deaths'] - covid_data['recovered']
# 4 Создадим признак ежедневного прироста числа заболевших, умерших и выздоровевших людей. Для этого отсортируем данные по названиям стран, а затем по датам. После этого произведём группировку по странам и рассчитаем разницу между «вчера и сегодня» с помощью метода diff():

covid_data = covid_data.sort_values(by=['country', 'date'])
covid_data['daily_confirmed'] = covid_data.groupby('country')['confirmed'].diff()
covid_data['daily_deaths'] = covid_data.groupby('country')['deaths'].diff()
covid_data['daily_recovered'] = covid_data.groupby('country')['recovered'].diff()

# В таблице vaccinations_data достаточно будет преобразовать столбцы в формат datetime:

vaccinations_data['date'] = pd.to_datetime(vaccinations_data['date'])

# За какой период представлены данные в таблице covid_data? 
# В качестве ответа введите даты в формате datetime (без указания времени).

print(f"Данные о заболеваемости предоставлены от {covid_data['date'].min()} до  {covid_data['date'].max()}")

#За какой период представлены данные в таблице vaccinations_data? 
# В качестве ответа введите даты в формате datetime без указания времени.

print(f"Данные о вакцинации предоставлены от {vaccinations_data['date'].min()} до  {vaccinations_data['date'].max()}")

# С помощью метода merge() объедините таблицы covid_data и vaccinations_data по столбцам date и country.
# Тип объединения выставьте так, чтобы в результирующую таблицу попали только наблюдения за период, 
# вычисленный в задании 3.1. То есть в результирующую таблицу должны попасть все записи из таблицы covid_data 
# и из её пересечения с vaccinations_data, но не более. Результат объединения занесите в переменную covid_df.
# Сколько строк и столбцов в таблице covid_df?
covid_df = covid_data.merge(vaccinations_data, on=['date', 'country'], how='left')
print('Число строк: ', covid_df.shape[0])
print('Число столбцов: ', covid_df.shape[1])

# В получившейся в задании 3.3 таблице covid_df создайте признаки death_rate — 
# общий процент смертей среди зафиксированных случаев (летальность) и recover_rate — 
# общий процент случаев выздоровления. Данные характеристики рассчитайте как отношение числа смертей (deaths) 
# и числа выздоровлений (recovered) к числу зафиксированных случаев (confirmed) и умножьте результаты на 100%.

# Какова максимальная летальность в США (United States) за весь период? Ответ округлите до второго знака после запятой.

covid_df['death_rate'] = covid_df['deaths'] / covid_df['confirmed'] * 100
covid_df['recover_rate'] = covid_df['recovered'] / covid_df['confirmed'] * 100
print(round(covid_df[covid_df['country'] == 'United States']['death_rate'].max(), 2))

# Чему равен средний процент выздоровевших в России (Russia)? Ответ округлите до второго знака после запятой

print(round(covid_df[covid_df['country'] == 'Russia']['recover_rate'].mean(), 2))

# Начнём с исследования заболеваемости коронавирусом во всём мире. Для этого первым делом отобразим, 
# как менялось ежедневное число заболевших (daily_confirmed) во всём мире во времени. Далее сгруппируем таблицу 
# по датам и подсчитаем суммарное число зафиксированных случаев по дням. Теперь мы наконец можем построить график 
# с помощью метода plot(). Будем использовать линейный график размером 12x4 
# (попробуйте взять другие числа, чтобы увидеть разницу). Подпишем график и отобразим сетку. Параметр lw (line width) 
# отвечает за ширину линии для линейного графика.

# для отображения графика нужно выгрузить модуль:
import matplotlib.pyplot as plt 
 
grouped_cases = covid_df.groupby('date')['daily_confirmed'].sum()
grouped_cases.plot(
    kind='line',
    figsize=(12, 4),
    title='Ежедневная заболеваемость по всем странам',
    grid = True,
    lw=3
)
# команда для вывода графика как картинки
plt.show()

# Теперь построим гистограмму, которая покажет распределение ежедневной заболеваемости во всём мире. 
# Для этого параметр kind выставляем на значение 'hist'. Параметр bins (корзины) отвечает за число 
# прямоугольников в гистограмме — пусть их будет 10 (попробуйте использовать другие числа, 
# чтобы увидеть разницу).

grouped_cases.plot(
    kind='hist',
    figsize=(10, 6),
    title='Распределение ежедневной заболеваемости',
    grid = True,
    color = 'black',
    bins=10
)


# Давайте построим столбчатую диаграмму, которая покажет ТОП-10 стран по суммарной заболеваемости.
# Для этого сгруппируем данные по странам и вычислим последний зафиксированный показатель 
# с помощью агрегирующего метода last() — он возвращает последнее значение в столбце DataFrame.
# Для построения столбчатой диаграммы значение параметра kind выставляем на 'bar'. 
# Параметр colormap отвечает за цветовую гамму графика.

grouped_country = covid_df.groupby(['country'])['confirmed'].last()
grouped_country = grouped_country.nlargest(10)
grouped_country.plot(
    kind='bar',
    grid=True,
    figsize=(12, 4),
    colormap='plasma'
)

# А теперь посмотрим, как в этих десяти странах соотносится количество заболевших и умерших от вируса. 
# Для этого отобразим сразу два показателя на столбчатой диаграмме: 

grouped_country = covid_df.groupby(['country'])[['confirmed', 'deaths']].last()
grouped_country = grouped_country.nlargest(10, columns=['confirmed'])
grouped_country.plot( 
    kind='bar', 
    grid=True, 
    figsize=(12, 4), 
)


covid_df.groupby(['country'])['total_vaccinations'].last().nsmallest(5).plot(kind='bar')


import matplotlib.pyplot as plt

# Процесс работы над графиком максимально прозрачен: сначала создаётся объект фигуры (fig) , 
# содержащий необходимую информацию и настройки, например размер в дюймах (figsize, восемь дюймов в ширину, 
# четыре — в высоту). К этому объекту с помощью метода add_axes() добавляется координатная плоскость, 
# а на ней располагаются графические объекты. Для создания координатной плоскости необходимо указать её 
# расположение на фигуре в виде списка из координат. В нашем случае она начинается в левом нижнем углу 
# без отступов (координаты 0, 0) и занимает всё отведённое место в области (100%, ширина и высота равны 1).

fig = plt.figure(figsize=(8, 4))
axes = fig.add_axes([0, 0, 1, 1])

# Теперь на созданной системе координат мы можем построить график. 
# Утверждается, что коллективная вакцинация позволяет минимизировать риск заражения коронавирусной 
# инфекцией (но только после второго компонента). Давайте проверим это на примере США: 
# построим диаграмму рассеяния, которая покажет зависимость числа ежедневно обнаруживаемых случаев заражения 
# (daily_confirmed) от общего количества привитых вторым компонентом вакцины (people_fully_vaccinated) в США.
# У объекта координатной плоскости axes вызовем метод scatter().

# а диаграмме рассеяния по оси абсцисс откладываем суммарное число поставленных вакцин, 
# а по оси ординат — ежедневный прирост заболевших:

us_data = covid_df[covid_df['country'] == 'United States']

fig = plt.figure(figsize=(8, 4))
axes = fig.add_axes([0, 0, 1, 1])
axes.scatter(
    x=us_data['people_fully_vaccinated'], 
    y=us_data['daily_confirmed'], 
    s=100,
    marker='o',
    c = 'blue'
)


# Построим круговую диаграмму, чтобы отобразить ТОП-10 комбинаций вакцин в мире.
# ТОП-10 комбинаций вакцин (vaccines) по распространённости мы находим с помощью метода value_counts(). 
# Круговую диаграмму строим на полученных значениях, метки для каждого значения — 
# индексы промежуточной таблицы. Будем отображать доли в процентах и округлять их до одного знака 
# после запятой. Самую распространённую вакцину сместим на 10 % от центра:

vaccine_combinations = covid_df['vaccines'].value_counts()[:10]
fig = plt.figure(figsize=(5, 5))
axes = fig.add_axes([0, 0, 1, 1])
axes.pie(
    vaccine_combinations,
    labels=vaccine_combinations.index,
    autopct='%.1f%%',
    explode = [0.1, 0, 0, 0, 0, 0, 0, 0, 0, 0]
)



# Обратите внимание, что диаграмма показывает соотношение только для десяти популярных комбинаций вакцин,
# а не для всех вакцин в совокупности, что является не совсем корректным для круговой диаграммы, 
# так как она должна отображать единое целое. К тому же наша круговая диаграмма считает 
# количество использований каждой комбинации в таблице, а не количество стран, в которых используется 
# эта комбинация, что также является некорректным. Более правильным вариантом в данном случае было 
# бы выделить каждую вакцину в отдельности и посчитать, в скольки странах она используется. 
# Однако для этого нам необходимо будет совершить несколько довольно сложных преобразований:
# Для начала нам необходимо избавиться от пропусков в столбце с вакцинами. 
# Сделаем это с помощью метода dropna(), который удаляет строки, содержащие пропуски в столбце, 
# указанном в параметре subset(). Данный метод мы будем изучать в следующем модуле, 
# посвящённом очистке данных — пока что не вам не стоит заострять на нём внимание:

combination_not_nan = covid_df.dropna(subset=['vaccines'])

# Полученные данные необходимо сгруппировать по странам (country) и определить 
# последнюю зафиксированную комбинации вакцин в столбце vaccines:

combination_last = combination_not_nan.groupby(['country'])['vaccines'].last()

# В результате такого преобразования мы получаем Series, значениями которого являются комбинации вакцин, 
# которые использовались в странах в последний день рассматриваемого периода.

print(combination_last)

# Преобразуем данные с помощью метода apply(): применим к столбцу lambda-функцию, 
# в которой будем удалять из строки с комбинациями вакцин пробелы и разделять комбинацию 
# на отдельные составляющие по запятым.

vaccines_unique = combination_last.apply(lambda x: x.replace(' ', '').split(','))

# В результате в каждой строке столбца получим список с отдельными вакцинами, 
# которые используются в стране:
# Создадим словарь vaccines_dict={}, ключами которого будут являться уникальные вакцины, 
# а значениями — количество стран, в которых они используются. Изначально словарь пустой.
# Заполнение словаря реализуем «в лоб» — используя циклы. Во внешнем цикле будем проходиться 
# по всем элементам Series combination_last. На каждой итерации цикла в переменной цикла 
# vaccines_list будет находиться список вакцин, которые используются в стране.
# Во внутреннем цикле будем проходиться по элементам этого списка, вакцинам. 
# Переменную внутреннего цикла назовём vaccine. В теле внутреннего цикла проверяем условие, 
# что текущей вакцины ещё нет среди ключей словаря vaccones_dict. Если это условие выполняется, 
# добавляем вакцину в словарь со значением 1. В противном случае увеличиваем текущее количество стран, 
# в которых используется данная вакцина:

vaccines_dict = {} 
#создаём цикл по элементам Series combination_last
for vaccines_list in combination_last:
    #создаём цикл по элементам списка с вакцинами
    for vaccine in vaccines_list:
        #проверяем условие, что текущей вакцины ещё нет среди ключей словаря
        if vaccine not in vaccines_dict:#если условие выполняется
            vaccines_dict[vaccine] = 1 #заносим вакцину в словарь со значением 1
        else: #в противном случае
            vaccines_dict[vaccine] += 1 #увеличивает количество


# В результате работы получаем словарь, который преобразуем в объект Series. 
# Далее выделим семь наиболее популярных вакцин, а остальные обозначим как 'other'.
# Для этого сортируем Series по убыванию. Вычислим суммарное количество стран, в которых используются вакцины,
# не попавшие в наш ТОП-7, результат запишем в Series по индексу 'other'.
# Далее выделим восемь наибольших значений в полученной Series — для них и будем строить круговую диаграмму.

vaccines = pd.Series(vaccines_dict).sort_values(ascending=False)
vaccines['other'] = vaccines[7:].sum()
vaccines = vaccines.sort_values(ascending=False)[:8]

# Строим круговую диаграмму:

fig = plt.figure(figsize=(5, 5))
axes = fig.add_axes([0, 0, 1, 1])
axes.pie(
    vaccines,
    labels=vaccines.index,
    autopct='%.1f%%',
)



# Например, изобразим на одном графике, как росла общая заболеваемость (confirmed), 
# число зафиксированных смертей (deaths), выздоровевших пациентов (recovered) и активных случаев (active) 
# в Китае.
# Для построения линейных графиков в Matplotlib используется метод plot() (не путайте с методом plot() 
# в Pandas!). При вызове метода без параметров по оси абсцисс откладываются значения столбца таблицы, 
# по оси ординат — индексы (в нашем случае это будут даты). 
# Дополнительно в параметрах метода указываем параметр label — название графика, 
# которое будет отображаться на легенде, а также lw — ширину линии графика. 
# Добавим к графику заголовок, названия осей, установим метки по оси y с частотой в 10 000, 
# повернём метки по оси x на 30 градусов, а также добавим легенду 
# (метки для легенды выставляются в параметре label метода plot()):

china_data = covid_df[covid_df['country'] == 'China']
china_grouped = china_data.groupby(['date'])[['confirmed', 'active', 'deaths', 'recovered']].sum()

#визуализация графиков
fig = plt.figure(figsize=(10, 4))
axes = fig.add_axes([0, 0, 1, 1])
axes.plot(china_grouped['confirmed'], label='Общее число зафиксированных случаев', lw=3)
axes.plot(china_grouped['deaths'], label='Общее число смертей', lw=3)
axes.plot(china_grouped['recovered'], label='Общее число выздоровевших пациентов', lw=3)
axes.plot(china_grouped['active'], label='Общее число активных случаев', lw=3, linestyle='dashed')

#установка параметров отображения
axes.set_title('Статистика Covid-19 в Китае', fontsize=16)
axes.set_xlabel('Даты')
axes.set_ylabel('Число случаев')
axes.set_yticks(range(0, 100000, 10000))
axes.xaxis.set_tick_params(rotation=30)
axes.grid()
axes.legend()



# При использовании библиотеки Matplotlib вовсе не обязательно ограничиваться одной системой координат.
# Вы можете размещать несколько систем координат на одной фигуре, что позволит нам 
# отображать вспомогательную информацию на основном графике. 
# Для добавления второй системы координат необходимо повторно применить к объекту fig метод add_axes, 
# указав новое имя для второй системы координат. 
# Например, отобразим ТОП-5 стран по общему числу привитых вторым компонентом людей (people_fully_vaccinated),
# а также ТОП-5 стран по числу полностью привитых на 100 человек населения 
# (people_fully_vaccinated_per_hundred).
# Для этого построим столбчатые диаграммы с помощью метода bar().

# Группируем таблицу по странам, находим последний по дате зафиксированный показатель с помощью
# метода last() и выбираем ТОП-5 стран с использованием метода nlargest(). 
# При отображении графиков создаём две координатные плоскости main_axes и insert_axes, 
# на каждой из них отдельно строим столбчатые диаграммы.

vacc_country = covid_df.groupby('country')['people_fully_vaccinated'].last().nlargest(5)
vacc_country_per_hundred = covid_df.groupby('country')['people_fully_vaccinated_per_hundred'].last().nlargest(5)

#визуализация главного графика
fig = plt.figure(figsize=(13, 4))
main_axes = fig.add_axes([0, 0, 1, 1])
main_axes.bar(x = vacc_country.index, height = vacc_country);
main_axes.set_ylabel('Число вакцинированных (2 компонент)')
main_axes.set_title('Топ 5 стран по числу полностью привитых людей')

#визуализация вспомогательного графика
insert_axes = fig.add_axes([0.6, 0.6, 0.38, 0.38])
insert_axes.bar(x = vacc_country_per_hundred.index, height = vacc_country_per_hundred, width=0.5);
insert_axes.set_ylabel('На 100 человек')
insert_axes.xaxis.set_tick_params(rotation=45)


# Примечание. Первые два числовых параметра, указанные при создании систем координат, 
# — это отступ снизу и слева, следующие два — ширина и высота относительно ширины и высоты всего пространства 
# (в долях единицы) для построения графика.

# следующий код создаст шесть координатных плоскостей, сведённых в таблицу размера 2x3:

fig, axes = plt.subplots(nrows=2, ncols=3, figsize=(10, 5))

# Теперь, обладая знаниями о методе subplots(), построим три графика:
# Столбчатую диаграмму, которая покажет динамику ежедневной вакцинации в России.
# Линейный график изменения ежедневной заболеваемости в стране.
# Гистограмму ежедневной заболеваемости в стране.
# За построение гистограмм в библиотеке Matplotlib отвечает метод hist().

# Фильтруем таблицу covid_df по признаку страны и выбираем записи только для России.
# Для того чтобы отобразить график в соответствующей координатной плоскости, 
# нужно обратиться к списку axes по индексу (от 0 до 2). Дальнейшая настройка графиков вам уже известна.

russia_data = covid_df[covid_df["country"] == "Russia"]

# визуализация систем координат
fig, axes = plt.subplots(nrows=1, ncols=3, figsize=(15, 4))

# столбчатая диаграмма
axes[0].bar(
    x=russia_data["date"],
    height=russia_data["daily_vaccinations"],
    label="Число вакцинированных",
)
axes[0].set_title("Ежедневная вакцинация в России")
axes[0].xaxis.set_tick_params(rotation=45)

# линейный график
axes[1].plot(
    russia_data["date"],
    russia_data["daily_confirmed"],
    label="Число заболевших",
    color="tomato",
    lw=2,
)
axes[1].set_title("Ежедневная заболеваемость в России")
axes[1].xaxis.set_tick_params(rotation=45)

# гистограмма
axes[2].hist(
    x=russia_data["daily_confirmed"], label=["Число заболевших"], color="lime", bins=20
)
axes[2].set_title("Гистограмма заболеваемости в России")
axes[2].xaxis.set_tick_params(rotation=30)

plt.show()

## SEABORN
# В данном разделе мы будем сравнивать несколько стран: Россию, Австралию, Германию, Канаду и Великобританию. 
# Создадим специальный DataFrame croped_covid_df для этих данных.
# Для фильтрации по списку значений используем метод isin(), который проверяет, есть ли запись в столбце 
# в переданном в метод списке. В результате возвращается привычная нам маска.
# А теперь снова немного магии Feature Engineering, чтобы показатели по странам стали сопоставимыми: 
# добавим информацию о населении стран, чтобы рассчитать ежедневную заболеваемость на 100 человек — 
# заболеваемость в процентах от общего количества населения (daily_confirmed_per_hundred).

import seaborn as sns

countries = ['Russia', 'Australia', 'Germany', 'Canada', 'United Kingdom']
croped_covid_df = covid_df[covid_df['country'].isin(countries)]

populations = pd.DataFrame([
    ['Canada', 37664517],
    ['Germany', 83721496],
    ['Russia', 145975300],
    ['Australia', 25726900],
    ['United Kingdom', 67802690]
    ],
    columns=['country', 'population']
)
croped_covid_df = croped_covid_df.merge(populations, on=['country'])
croped_covid_df['daily_confirmed_per_hundred'] = croped_covid_df['daily_confirmed'] / croped_covid_df['population'] * 100
croped_covid_df.head()

# Построим сразу две гистограммы: одна будет иллюстрировать общее распределение ежедневной заболеваемости 
# (daily_confirmed), а вторая — то же распределение в разрезе стран. 
# Для этого создаём две координатные плоскости с помощью метода subplots(). 
# На первой координатной плоскости рисуем простую гистограмму с 25 столбцами, 
# а также добавим на неё сглаживающую кривую. 
# На второй гистограмме добавляем параметр названия страны по оси y. В таком случае количество наблюдений 
# будет обозначаться на диаграмме яркостью цвета (чем темнее полоса, тем больше наблюдений находится в
# интервале).

fig, axes = plt.subplots(nrows=2, ncols=1, figsize=(10, 8))
sns.histplot(
    data=croped_covid_df,
    x='daily_confirmed_per_hundred',
    bins=25,
    kde=True,
    ax=axes[0]
)
axes[0].set_title('Гистограмма ежедневной заболеваемости на 100 человек', fontsize=16)
sns.histplot(
    data=croped_covid_df,
    x='daily_confirmed_per_hundred',
    y='country',
    bins=25,
    color='red',
    ax=axes[1]
)

# Рассмотрим пример — построим коробчатые диаграммы признака летальности (death_rate), 
# который вы создавали ранее в задании 3.3.
# Коробчатые диаграммы в Seaborn строятся с помощью метода boxplot().
# Ящики отразим горизонтально (для этого по оси x отложим признак летальности, а по оси y — страны), 
# параметр orient отвечает за ориентацию диаграммы, а width — за ширину коробок:

fig = plt.figure(figsize=(10, 7))
boxplot = sns.boxplot(
    data=croped_covid_df,
    y='country',
    x='death_rate',
    orient='h',
    width=0.9
)
boxplot.set_title('Распределение летальности по странам')
boxplot.set_xlabel('Летальность')
boxplot.set_ylabel('Страна')
boxplot.grid()

# Теперь рассмотрим пример многоуровневой столбчатой диаграммы. С помощью неё мы можем, например, посмотреть 
# на средний ежедневный процент заболевших в странах по кварталам.
# Для построения столбчатых диаграмм в Seaborn используется метод barplot(). 
# По умолчанию метод отображает среднее по столбцу, который указан в параметре x 
# (вместо среднего можно вычислить и любую другую статистическую характеристику, наименование 
# оторой задаётся в параметре estimator). Для добавления многоуровневости используется 
# араметр hue, который позволяет группировать данные по признаку:

fig = plt.figure(figsize=(10, 7))
croped_covid_df['quarter'] = croped_covid_df['date'].dt.quarter
barplot = sns.barplot(
    data=croped_covid_df,
    x='country',
    y='daily_confirmed_per_hundred',
    hue='quarter',
)
barplot.set_title('Средний процент болеющего населения по кварталам')

# Построим один из самых любимых дата-сайентистами графиков — jointplot() — 
# в котором совмещены диаграмма рассеяния и гистограмма. Это довольно удобный и полезный инструмент, 
# когда мы хотим одновременно посмотреть и на распределения переменных, и сразу оценить их взаимосвязь.
# Построим jointplot зависимости ежедневной заболеваемости в странах от общей численности населения 
# в процентах (daily_confirmed_per_hundred) от числа полностью вакцинированных в процентах 
# (people_fully_vaccinated_per_hundred).
# Параметры xlim и ylim определяют диапазон отображения осей x и y. Параметр height отвечает за высоту 
# и ширину графика (он квадратный).

jointplot = sns.jointplot(
    data=croped_covid_df, 
    x='people_fully_vaccinated_per_hundred', 
    y='daily_confirmed_per_hundred',
    hue='country',
    xlim = (0, 40),
    ylim = (0, 0.1),
    height=8,
)

# Допустим, мы хотим сравнить темпы вакцинации по странам во времени. Вы, скорее всего, сразу подумали 
# о линейном графике. Но давайте мыслить шире. Когда мы хотим сравнить скорость изменения показателей 
# по малому количеству категорий (в данном случае — по странам, а их у нас их всего пять), нагляднее всего 
# будет тепловая карта.
# Предварительно создадим сводную таблицу: по столбцам отложим признак даты, а по строкам — страны. 
# В ячейках таблицы будет находиться процент вакцинированных (первым компонентом) людей в стране на 
# определённую дату. Чтобы даты отображались на тепловой карте верно, их необходимо привести к типу string.

pivot = croped_covid_df.pivot_table(
    values='people_vaccinated_per_hundred',
    columns='date',
    index='country',
)
pivot.columns = pivot.columns.astype('string')
print(pivot)

# Для построения тепловой карты в Seaborn используется метод heatmap(). Данный метод работает с 
# табличными данными и визуализирует все ячейки таблицы с помощью цвета. Параметр annot отвечает за 
# отображение легенды (аннотации), параметр cmap — за цветовую гамму графика.

heatmap = sns.heatmap(data=pivot, cmap='YlGnBu')
heatmap.set_title('Тепловая карта вакцинации', fontsize=16);

# Создайте новый признак confirmed_per_hundred, который покажет процентное отношение заболевших вирусом к 
# общему числу населения в странах (confirmed / population * 100).
# Постройте тепловую карту, которая покажет, как росло число заболевших в процентах от общего
# числа населения (confirmed_per_hundred) в странах из таблицы croped_covid_df.
# Выберите верные выводы по построенному графику:

croped_covid_df['confirmed_per_hundred'] = croped_covid_df['confirmed']/croped_covid_df['population'] * 100
pivot = croped_covid_df.pivot_table(
    values='confirmed_per_hundred',
    columns='date',
    index='country'
)
pivot.columns = pivot.columns.astype('string')
fig = plt.figure(figsize=(10, 5))

heatmap = sns.heatmap(data=pivot, cmap='plasma')
heatmap.set_title('Тепловая карта заболеваемости', fontsize=16)

# Постройте коробчатую диаграмму для признака recover_rate (отношение выздоровлений к числу 
# зафиксированных случаев заболевания в процентах).
# Выберите верные выводы по данному графику:

fig = plt.figure(figsize=(10, 7))
boxplot = sns.boxplot(
    data=croped_covid_df,
    x='country',
    y='recover_rate',
    orient='v',
    width=0.9
)

# PLOTLY

import plotly
import plotly.express as px

# Дальнейшая работа будет вестись с таблицей covid_df — полными данными о статистике 
# распространения вируса Covid-19, а также о вакцинации в разных странах.

# Построим график роста зафиксированного числа случаев заражения (confirmed), смертей (deaths), 
# выздоровлений (recovered) и активных случаев (active) за всё время. Для этого просуммируем статистику 
# по дням и передадим полученный DataFrame в метод line().
# Для отображения созданной методом line() фигуры используется метод fig.show():

line_data = covid_df.groupby('date', as_index=False).sum()
fig = px.line(
    data_frame=line_data, #DataFrame
    x='date', #ось абсцисс
    y=['confirmed', 'recovered', 'deaths', 'active'], #ось ординат
    height=500, #высота
    width=1000, #ширина
    title='Confirmed, Recovered, Deaths, Active cases over Time' #заголовок
)

# Давайте рассмотрим ещё один пример — построим столбчатую диаграмму, показывающую ТОП-10 стран 
# по среднему проценту выздоравливающих пациентов (recover_rate). Для этого используем метод bar() 
# модуля express. 

#считаем средний процент выздоровлений для каждой страны
bar_data = covid_df.groupby(
    by='country',
    as_index=False
)[['recover_rate']].mean().round(2).nlargest(10, columns=['recover_rate'])

#строим график
fig = px.bar(
    data_frame=bar_data, #датафрейм
    x="country", #ось x
    y="recover_rate", #ось y
    color='country', #расцветка в зависимости от страны
    text = 'recover_rate', #текст на столбцах
    orientation='v', #ориентация графика
    height=500, #высота
    width=1000, #ширина
    title='Top 10 Countries for Recovery Rate' #заголовок
)

#отображаем его

# В полученных данных вы можете увидеть «страну» Diamond Princess. Напомним, что это круизный лайнер,
# на котором в начале февраля 2020 года выявили заражённого Covid-19, после чего все пассажиры 
# оказались изолированы на судне из-за карантинных мер. Последние пассажиры сошли на берег лишь 1 марта. 


#  Построим иерархическую диаграмму для среднего ежедневного показателя выздоровевших пациентов 
# (daily_recovered) во всех странах.

#считаем среднее ежедневно фиксируемое количество выздоровевших по странам
treemap_data = covid_df.groupby(
    by='country',
    as_index=False
)[['daily_recovered']].mean()

#строим график
fig = px.treemap(
    data_frame=treemap_data, #DataFrame
    path=['country'], #категориальный признак, для которого строится график
    values='daily_recovered', #параметр, который сравнивается
    height=500, #высота
    width=1000, #ширина
    title='Daily Recovered Cases by Country' #заголовок
)

#отображаем график


# Итак, построим фоновую картограмму, которая покажет распространение (confirmed) 
# коронавируса в мире во времени. 
# Предварительно для правильного отображения на анимационном бегунке даты в таблице covid_df 
# необходимо перевести обратно в строковый тип данных.

#преобразуем даты в строковый формат
choropleth_data = covid_df.sort_values(by='date')
choropleth_data['date'] = choropleth_data['date'].astype('string')

#строим график
fig = px.choropleth(
    data_frame=choropleth_data, #DataFrame
    locations="country", #столбец с локациями
    locationmode = "country names", #режим сопоставления локаций с базой Plotly
    color="confirmed", #от чего зависит цвет
    animation_frame="date", #анимационный бегунок
    range_color=[0, 30e6], #диапазон цвета
    title='Global Spread of COVID-19', #заголовок
    width=800, #ширина
    height=500, #высота
    color_continuous_scale='Reds' #палитра цветов
)

#отображаем график

# Построим 3D-диаграмму рассеяния, которая покажет, как число ежедневно обнаруживаемых случаев и число 
# ежедневных смертей влияют на желание людей вакцинироваться. Для того чтобы нам было проще 
# рассматривать диаграмму (точки будут более сгруппированными), построим её в логарифмическом масштабе 
# по осям абсцисс и ординат.

# Чтобы не перегрузить график, будем строить зависимость только в нескольких странах: США, России, 
# Великобритании, Бразилии и Франции. Наблюдения для каждой страны окрасим разными цветами.

#фильтруем таблицу по странам
countries=['United States', 'Russia', 'United Kingdom', 'Brazil', 'France']
scatter_data = covid_df[covid_df['country'].isin(countries)]

#строим график
fig = px.scatter_3d(
    data_frame=scatter_data, #DataFrame
    x = 'daily_confirmed', #ось абсцисс
    y = 'daily_deaths', #ось ординат
    z = 'daily_vaccinations', #ось аппликат
    color='country', #расцветка в зависимости от страны
    log_x=True, 
    log_y=True,
    width=1000,
    height=700
)

#отображаем график

# сохранение графика: fig.write_html("plotly/scatter_3d.html")


# Постройте линейный график, который отображает, как изменялось ежедневное количество вакцинированных 
# (daily_vaccinations) в мире во времени. Из графика найдите, чему равно количество вакцинированных 
# (в миллионах) 28 февраля 2021 года (2021-02-28). Ответ округлите до целого числа.


line_data = covid_df.groupby('date', as_index=False)['daily_vaccinations'].sum()
fig = px.line(data_frame=line_data, x = 'date', y='daily_vaccinations')


# Постройте анимированную тепловую картограмму для числа поставленных вакцин во всём мире (total_vaccinations).
# На полученной карте найдите, чему равно количество вакцинированных в Японии (Japan) на 
# 24 марта 2021 года (2021-03-24). Ответ приведите в тысячах (без нулей) и округлите до целого числа.
# Примечание. Если в jupyter notebook в VS Code не запускается анимация тепловой карты, 
# попробуйте отобразить график командой fig.show(renderer='notebook').

choropleth_data = covid_df.sort_values(by='date')
choropleth_data['date'] = choropleth_data['date'].astype('string')
fig = px.choropleth(
    data_frame=choropleth_data, #DataFrame
    locations="country", #столбец с локациями
    locationmode = "country names", #режим сопоставления локаций с базой Plotly
    color="total_vaccinations", #от чего зависит цвет
    hover_name="country", #группирующая переменная
    animation_frame="date", #анимационный бегунок
    color_continuous_scale='Reds', #палитра цветов
    range_color=[0, 600e6] #диапазон цвета
)

fig.show()

