import pandas as pd

covid_data = pd.read_csv('data/covid_data.csv')
print(covid_data.head())

# Мы будем работать со следующими столбцами:
# date — дата наблюдения
# province/state — наименование провинции/штата;
# country — наименование страны;
# confirmed — общее число зафиксированных случаев на указанный день;
# deaths — общее число зафиксированных смертей на указанный день;
# recovered — общее число выздоровлений на указанный день.

vaccinations_data = pd.read_csv('data/country_vaccinations.csv')
vaccinations_data = vaccinations_data[
    ['country', 'date', 'total_vaccinations', 
     'people_vaccinated', 'people_vaccinated_per_hundred',
     'people_fully_vaccinated', 'people_fully_vaccinated_per_hundred',
     'daily_vaccinations', 'vaccines']
]

#Данная таблица содержит следующие столбцы:
# country — наименование страны;
# date — дата наблюдения;
# total_vaccinations — общее число введённых вакцин в стране на указанный день;
# people_vaccinated — общее число привитых первым компонентом в стране на указанный день;
# people_vaccinated_per_hundred — процент привитых первым компонентом в стране на указанный день (рассчитывается как );
# people_fully_vaccinated — общее число привитых вторым компонентом в стране на указанный день (первый компонент уже был введён им ранее);
# people_fully_vaccinated_per_hundred — процент привитых вторым компонентом в стране на указанный день (рассчитывается как );
# daily_vaccination — ежедневная вакцинация (число вакцинированных в указанный день);
# vaccines — комбинации вакцин, используемые в стране.

# В таблице covid_data:
# 1 Группируем таблицу по дате и названию страны и рассчитываем суммарные показатели по всем регионам. Тем самым переходим от данных по регионам к данным по странам:

covid_data = covid_data.groupby(
    ['date', 'country'], 
    as_index=False
)[['confirmed', 'deaths', 'recovered']].sum()

# 2 Преобразуем даты в формат datetime с помощью функции pd.to_datetime():

covid_data['date'] = pd.to_datetime(covid_data['date'])

# 3 Создадим признак больных на данный момент (active). Для этого вычтем из общего числа зафиксированных случаев число смертей и число выздоровевших пациентов:

covid_data['active'] = covid_data['confirmed'] - covid_data['deaths'] - covid_data['recovered']
# 4 Создадим признак ежедневного прироста числа заболевших, умерших и выздоровевших людей. Для этого отсортируем данные по названиям стран, а затем по датам. После этого произведём группировку по странам и рассчитаем разницу между «вчера и сегодня» с помощью метода diff():

covid_data = covid_data.sort_values(by=['country', 'date'])
covid_data['daily_confirmed'] = covid_data.groupby('country')['confirmed'].diff()
covid_data['daily_deaths'] = covid_data.groupby('country')['deaths'].diff()
covid_data['daily_recovered'] = covid_data.groupby('country')['recovered'].diff()

# В таблице vaccinations_data достаточно будет преобразовать столбцы в формат datetime:

vaccinations_data['date'] = pd.to_datetime(vaccinations_data['date'])

# За какой период представлены данные в таблице covid_data? 
# В качестве ответа введите даты в формате datetime (без указания времени).

print(f"Данные о заболеваемости предоставлены от {covid_data['date'].min()} до  {covid_data['date'].max()}")

#За какой период представлены данные в таблице vaccinations_data? 
# В качестве ответа введите даты в формате datetime без указания времени.

print(f"Данные о вакцинации предоставлены от {vaccinations_data['date'].min()} до  {vaccinations_data['date'].max()}")

# С помощью метода merge() объедините таблицы covid_data и vaccinations_data по столбцам date и country.
# Тип объединения выставьте так, чтобы в результирующую таблицу попали только наблюдения за период, 
# вычисленный в задании 3.1. То есть в результирующую таблицу должны попасть все записи из таблицы covid_data 
# и из её пересечения с vaccinations_data, но не более. Результат объединения занесите в переменную covid_df.
# Сколько строк и столбцов в таблице covid_df?
covid_df = covid_data.merge(vaccinations_data, on=['date', 'country'], how='left')
print('Число строк: ', covid_df.shape[0])
print('Число столбцов: ', covid_df.shape[1])

# В получившейся в задании 3.3 таблице covid_df создайте признаки death_rate — 
# общий процент смертей среди зафиксированных случаев (летальность) и recover_rate — 
# общий процент случаев выздоровления. Данные характеристики рассчитайте как отношение числа смертей (deaths) 
# и числа выздоровлений (recovered) к числу зафиксированных случаев (confirmed) и умножьте результаты на 100%.

# Какова максимальная летальность в США (United States) за весь период? Ответ округлите до второго знака после запятой.

covid_df['death_rate'] = covid_df['deaths'] / covid_df['confirmed'] * 100
covid_df['recover_rate'] = covid_df['recovered'] / covid_df['confirmed'] * 100
print(round(covid_df[covid_df['country'] == 'United States']['death_rate'].max(), 2))

# Чему равен средний процент выздоровевших в России (Russia)? Ответ округлите до второго знака после запятой

print(round(covid_df[covid_df['country'] == 'Russia']['recover_rate'].mean(), 2))

# Начнём с исследования заболеваемости коронавирусом во всём мире. Для этого первым делом отобразим, 
# как менялось ежедневное число заболевших (daily_confirmed) во всём мире во времени. Далее сгруппируем таблицу 
# по датам и подсчитаем суммарное число зафиксированных случаев по дням. Теперь мы наконец можем построить график 
# с помощью метода plot(). Будем использовать линейный график размером 12x4 
# (попробуйте взять другие числа, чтобы увидеть разницу). Подпишем график и отобразим сетку. Параметр lw (line width) 
# отвечает за ширину линии для линейного графика.

# для отображения графика нужно выгрузить модуль:
import matplotlib.pyplot as plt 
 
grouped_cases = covid_df.groupby('date')['daily_confirmed'].sum()
grouped_cases.plot(
    kind='line',
    figsize=(12, 4),
    title='Ежедневная заболеваемость по всем странам',
    grid = True,
    lw=3
)
# команда для вывода графика как картинки
plt.show()

# Теперь построим гистограмму, которая покажет распределение ежедневной заболеваемости во всём мире. 
# Для этого параметр kind выставляем на значение 'hist'. Параметр bins (корзины) отвечает за число 
# прямоугольников в гистограмме — пусть их будет 10 (попробуйте использовать другие числа, 
# чтобы увидеть разницу).

grouped_cases.plot(
    kind='hist',
    figsize=(10, 6),
    title='Распределение ежедневной заболеваемости',
    grid = True,
    color = 'black',
    bins=10
)

plt.show()

# Давайте построим столбчатую диаграмму, которая покажет ТОП-10 стран по суммарной заболеваемости.
# Для этого сгруппируем данные по странам и вычислим последний зафиксированный показатель 
# с помощью агрегирующего метода last() — он возвращает последнее значение в столбце DataFrame.
# Для построения столбчатой диаграммы значение параметра kind выставляем на 'bar'. 
# Параметр colormap отвечает за цветовую гамму графика.

grouped_country = covid_df.groupby(['country'])['confirmed'].last()
grouped_country = grouped_country.nlargest(10)
grouped_country.plot(
    kind='bar',
    grid=True,
    figsize=(12, 4),
    colormap='plasma'
)
plt.show()

# А теперь посмотрим, как в этих десяти странах соотносится количество заболевших и умерших от вируса. 
# Для этого отобразим сразу два показателя на столбчатой диаграмме: 

grouped_country = covid_df.groupby(['country'])[['confirmed', 'deaths']].last()
grouped_country = grouped_country.nlargest(10, columns=['confirmed'])
grouped_country.plot( 
    kind='bar', 
    grid=True, 
    figsize=(12, 4), 
)
plt.show()

covid_df.groupby(['country'])['total_vaccinations'].last().nsmallest(5).plot(kind='bar')
plt.show()

import matplotlib.pyplot as plt

# Процесс работы над графиком максимально прозрачен: сначала создаётся объект фигуры (fig) , 
# содержащий необходимую информацию и настройки, например размер в дюймах (figsize, восемь дюймов в ширину, 
# четыре — в высоту). К этому объекту с помощью метода add_axes() добавляется координатная плоскость, 
# а на ней располагаются графические объекты. Для создания координатной плоскости необходимо указать её 
# расположение на фигуре в виде списка из координат. В нашем случае она начинается в левом нижнем углу 
# без отступов (координаты 0, 0) и занимает всё отведённое место в области (100%, ширина и высота равны 1).

fig = plt.figure(figsize=(8, 4))
axes = fig.add_axes([0, 0, 1, 1])

# Теперь на созданной системе координат мы можем построить график. 
# Утверждается, что коллективная вакцинация позволяет минимизировать риск заражения коронавирусной 
# инфекцией (но только после второго компонента). Давайте проверим это на примере США: 
# построим диаграмму рассеяния, которая покажет зависимость числа ежедневно обнаруживаемых случаев заражения 
# (daily_confirmed) от общего количества привитых вторым компонентом вакцины (people_fully_vaccinated) в США.
# У объекта координатной плоскости axes вызовем метод scatter().

# а диаграмме рассеяния по оси абсцисс откладываем суммарное число поставленных вакцин, 
# а по оси ординат — ежедневный прирост заболевших:

us_data = covid_df[covid_df['country'] == 'United States']

fig = plt.figure(figsize=(8, 4))
axes = fig.add_axes([0, 0, 1, 1])
axes.scatter(
    x=us_data['people_fully_vaccinated'], 
    y=us_data['daily_confirmed'], 
    s=100,
    marker='o',
    c = 'blue'
)
plt.show()

# Построим круговую диаграмму, чтобы отобразить ТОП-10 комбинаций вакцин в мире.
# ТОП-10 комбинаций вакцин (vaccines) по распространённости мы находим с помощью метода value_counts(). 
# Круговую диаграмму строим на полученных значениях, метки для каждого значения — 
# индексы промежуточной таблицы. Будем отображать доли в процентах и округлять их до одного знака 
# после запятой. Самую распространённую вакцину сместим на 10 % от центра:

vaccine_combinations = covid_df['vaccines'].value_counts()[:10]
fig = plt.figure(figsize=(5, 5))
axes = fig.add_axes([0, 0, 1, 1])
axes.pie(
    vaccine_combinations,
    labels=vaccine_combinations.index,
    autopct='%.1f%%',
    explode = [0.1, 0, 0, 0, 0, 0, 0, 0, 0, 0]
)

plt.show()

# Обратите внимание, что диаграмма показывает соотношение только для десяти популярных комбинаций вакцин,
# а не для всех вакцин в совокупности, что является не совсем корректным для круговой диаграммы, 
# так как она должна отображать единое целое. К тому же наша круговая диаграмма считает 
# количество использований каждой комбинации в таблице, а не количество стран, в которых используется 
# эта комбинация, что также является некорректным. Более правильным вариантом в данном случае было 
# бы выделить каждую вакцину в отдельности и посчитать, в скольки странах она используется. 
# Однако для этого нам необходимо будет совершить несколько довольно сложных преобразований:
# Для начала нам необходимо избавиться от пропусков в столбце с вакцинами. 
# Сделаем это с помощью метода dropna(), который удаляет строки, содержащие пропуски в столбце, 
# указанном в параметре subset(). Данный метод мы будем изучать в следующем модуле, 
# посвящённом очистке данных — пока что не вам не стоит заострять на нём внимание:

combination_not_nan = covid_df.dropna(subset=['vaccines'])

# Полученные данные необходимо сгруппировать по странам (country) и определить 
# последнюю зафиксированную комбинации вакцин в столбце vaccines:

combination_last = combination_not_nan.groupby(['country'])['vaccines'].last()

# В результате такого преобразования мы получаем Series, значениями которого являются комбинации вакцин, 
# которые использовались в странах в последний день рассматриваемого периода.

print(combination_last)

# Преобразуем данные с помощью метода apply(): применим к столбцу lambda-функцию, 
# в которой будем удалять из строки с комбинациями вакцин пробелы и разделять комбинацию 
# на отдельные составляющие по запятым.

vaccines_unique = combination_last.apply(lambda x: x.replace(' ', '').split(','))

# В результате в каждой строке столбца получим список с отдельными вакцинами, 
# которые используются в стране:
# Создадим словарь vaccines_dict={}, ключами которого будут являться уникальные вакцины, 
# а значениями — количество стран, в которых они используются. Изначально словарь пустой.
# Заполнение словаря реализуем «в лоб» — используя циклы. Во внешнем цикле будем проходиться 
# по всем элементам Series combination_last. На каждой итерации цикла в переменной цикла 
# vaccines_list будет находиться список вакцин, которые используются в стране.
# Во внутреннем цикле будем проходиться по элементам этого списка, вакцинам. 
# Переменную внутреннего цикла назовём vaccine. В теле внутреннего цикла проверяем условие, 
# что текущей вакцины ещё нет среди ключей словаря vaccones_dict. Если это условие выполняется, 
# добавляем вакцину в словарь со значением 1. В противном случае увеличиваем текущее количество стран, 
# в которых используется данная вакцина:

vaccines_dict = {} 
#создаём цикл по элементам Series combination_last
for vaccines_list in combination_last:
    #создаём цикл по элементам списка с вакцинами
    for vaccine in vaccines_list:
        #проверяем условие, что текущей вакцины ещё нет среди ключей словаря
        if vaccine not in vaccines_dict:#если условие выполняется
            vaccines_dict[vaccine] = 1 #заносим вакцину в словарь со значением 1
        else: #в противном случае
            vaccines_dict[vaccine] += 1 #увеличивает количество


# В результате работы получаем словарь, который преобразуем в объект Series. 
# Далее выделим семь наиболее популярных вакцин, а остальные обозначим как 'other'.
# Для этого сортируем Series по убыванию. Вычислим суммарное количество стран, в которых используются вакцины,
# не попавшие в наш ТОП-7, результат запишем в Series по индексу 'other'.
# Далее выделим восемь наибольших значений в полученной Series — для них и будем строить круговую диаграмму.

vaccines = pd.Series(vaccines_dict).sort_values(ascending=False)
vaccines['other'] = vaccines[7:].sum()
vaccines = vaccines.sort_values(ascending=False)[:8]

# Строим круговую диаграмму:

fig = plt.figure(figsize=(5, 5))
axes = fig.add_axes([0, 0, 1, 1])
axes.pie(
    vaccines,
    labels=vaccines.index,
    autopct='%.1f%%',
)

plt.show()

# Например, изобразим на одном графике, как росла общая заболеваемость (confirmed), 
# число зафиксированных смертей (deaths), выздоровевших пациентов (recovered) и активных случаев (active) 
# в Китае.
# Для построения линейных графиков в Matplotlib используется метод plot() (не путайте с методом plot() 
# в Pandas!). При вызове метода без параметров по оси абсцисс откладываются значения столбца таблицы, 
# по оси ординат — индексы (в нашем случае это будут даты). 
# Дополнительно в параметрах метода указываем параметр label — название графика, 
# которое будет отображаться на легенде, а также lw — ширину линии графика. 
# Добавим к графику заголовок, названия осей, установим метки по оси y с частотой в 10 000, 
# повернём метки по оси x на 30 градусов, а также добавим легенду 
# (метки для легенды выставляются в параметре label метода plot()):

china_data = covid_df[covid_df['country'] == 'China']
china_grouped = china_data.groupby(['date'])[['confirmed', 'active', 'deaths', 'recovered']].sum()

#визуализация графиков
fig = plt.figure(figsize=(10, 4))
axes = fig.add_axes([0, 0, 1, 1])
axes.plot(china_grouped['confirmed'], label='Общее число зафиксированных случаев', lw=3)
axes.plot(china_grouped['deaths'], label='Общее число смертей', lw=3)
axes.plot(china_grouped['recovered'], label='Общее число выздоровевших пациентов', lw=3)
axes.plot(china_grouped['active'], label='Общее число активных случаев', lw=3, linestyle='dashed')

#установка параметров отображения
axes.set_title('Статистика Covid-19 в Китае', fontsize=16)
axes.set_xlabel('Даты')
axes.set_ylabel('Число случаев')
axes.set_yticks(range(0, 100000, 10000))
axes.xaxis.set_tick_params(rotation=30)
axes.grid()
axes.legend()

plt.show()

# При использовании библиотеки Matplotlib вовсе не обязательно ограничиваться одной системой координат.
# Вы можете размещать несколько систем координат на одной фигуре, что позволит нам 
# отображать вспомогательную информацию на основном графике. 
# Для добавления второй системы координат необходимо повторно применить к объекту fig метод add_axes, 
# указав новое имя для второй системы координат. 
# Например, отобразим ТОП-5 стран по общему числу привитых вторым компонентом людей (people_fully_vaccinated),
# а также ТОП-5 стран по числу полностью привитых на 100 человек населения 
# (people_fully_vaccinated_per_hundred).
# Для этого построим столбчатые диаграммы с помощью метода bar().

# Группируем таблицу по странам, находим последний по дате зафиксированный показатель с помощью
# метода last() и выбираем ТОП-5 стран с использованием метода nlargest(). 
# При отображении графиков создаём две координатные плоскости main_axes и insert_axes, 
# на каждой из них отдельно строим столбчатые диаграммы.

vacc_country = covid_df.groupby('country')['people_fully_vaccinated'].last().nlargest(5)
vacc_country_per_hundred = covid_df.groupby('country')['people_fully_vaccinated_per_hundred'].last().nlargest(5)

#визуализация главного графика
fig = plt.figure(figsize=(13, 4))
main_axes = fig.add_axes([0, 0, 1, 1])
main_axes.bar(x = vacc_country.index, height = vacc_country);
main_axes.set_ylabel('Число вакцинированных (2 компонент)')
main_axes.set_title('Топ 5 стран по числу полностью привитых людей')

#визуализация вспомогательного графика
insert_axes = fig.add_axes([0.6, 0.6, 0.38, 0.38])
insert_axes.bar(x = vacc_country_per_hundred.index, height = vacc_country_per_hundred, width=0.5);
insert_axes.set_ylabel('На 100 человек')
insert_axes.xaxis.set_tick_params(rotation=45)

plt.show()

# Примечание. Первые два числовых параметра, указанные при создании систем координат, 
# — это отступ снизу и слева, следующие два — ширина и высота относительно ширины и высоты всего пространства 
# (в долях единицы) для построения графика.

# следующий код создаст шесть координатных плоскостей, сведённых в таблицу размера 2x3:



# Теперь, обладая знаниями о методе subplots(), построим три графика:
# Столбчатую диаграмму, которая покажет динамику ежедневной вакцинации в России.
# Линейный график изменения ежедневной заболеваемости в стране.
# Гистограмму ежедневной заболеваемости в стране.
# За построение гистограмм в библиотеке Matplotlib отвечает метод hist().

# Фильтруем таблицу covid_df по признаку страны и выбираем записи только для России.
# Для того чтобы отобразить график в соответствующей координатной плоскости, 
# нужно обратиться к списку axes по индексу (от 0 до 2). Дальнейшая настройка графиков вам уже известна.

russia_data = covid_df[covid_df["country"] == "Russia"]

# визуализация систем координат
fig, axes = plt.subplots(nrows=1, ncols=3, figsize=(15, 4))

# столбчатая диаграмма
axes[0].bar(
    x=russia_data["date"],
    height=russia_data["daily_vaccinations"],
    label="Число вакцинированных",
)
axes[0].set_title("Ежедневная вакцинация в России")
axes[0].xaxis.set_tick_params(rotation=45)

# линейный график
axes[1].plot(
    russia_data["date"],
    russia_data["daily_confirmed"],
    label="Число заболевших",
    color="tomato",
    lw=2,
)
axes[1].set_title("Ежедневная заболеваемость в России")
axes[1].xaxis.set_tick_params(rotation=45)

# гистограмма
axes[2].hist(
    x=russia_data["daily_confirmed"], label=["Число заболевших"], color="lime", bins=20
)
axes[2].set_title("Гистограмма заболеваемости в России")
axes[2].xaxis.set_tick_params(rotation=30)

plt.show()