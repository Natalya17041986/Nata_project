import pandas as pd

# прочитаем первые пять строк таблицы
melb_df = pd.read_csv('data/melb_data_fe.csv')
print(melb_df.head())


# смотрим инфо о файле
print(melb_df.info())
# преобразование столбцов к типам datetime и category «слетело»


# Преобразовываем столбец Date в формат datetime и выделяем квартал (quarter) продажи объектов недвижимости. 
# Находим второй по популярности квартал продажи. Считаем число объектов, проданных в этом квартале.
melb_df['Date'] = pd.to_datetime(melb_df['Date'])
quarters = melb_df['Date'].dt.quarter
print(quarters.value_counts().iloc[1])

# Преобразовываем все столбцы, в которых меньше 150 уникальных значений, в тип данных category, 
# исключив из преобразования столбцы Date, Rooms, Bedroom, Bathroom, Car.
# Считаем результирующее количество столбцов, которые имеют тип данных category.
cols_to_exclude = ['Date', 'Rooms', 'Bedroom', 'Bathroom', 'Car'] 
max_unique_count = 150 
for col in melb_df.columns: 
    if melb_df[col].nunique() < max_unique_count and col not in cols_to_exclude: 
        melb_df[col] = melb_df[col].astype('category')
print(melb_df.info())

# Отсортируем таблицу по возрастанию цены объектов недвижимости (Price)
print(melb_df.sort_values(by='Price').head(10))

# отсортируем таблицу по убыванию (от самой последней до самой первой) даты продажи объекта (Date). 
# Для этого выставим параметр ascending на False
print(melb_df.sort_values(by='Date', ascending=False))

# отсортируем таблицу сначала по возрастанию расстояния от центра города (Distance), 
# а затем — по возрастанию цены объекта (Price). 
# Для того чтобы вывод был более наглядным, выделим каждую десятую строку из столбцов Distance и Price результирующей таблицы:
print(melb_df.sort_values(by=['Distance', 'Price']).loc[::10, ['Distance', 'Price']])
#Если встречаются объекты недвижимости, у которых расстояние оказывается одинаковым, 
# то внутри такой группы производится сортировка по цене объекта.

# Найдём информацию о таунхаусах (Type), проданных компанией (SellerG) McGrath, 
# у которых коэффициент соотношения площадей здания и участка (AreaRatio) меньше -0.8. 
# Результат отсортируем по дате продажи (Date) в порядке возрастания, а после проведём сортировку 
# по убыванию коэффициента соотношения площадей. Также обновим старые индексы на новые, 
# установив параметр ignore_index на True. Для наглядности результата выберем из таблицы только столбцы SellerG и AreaRatio:
mask1 = melb_df['AreaRatio'] < -0.8
mask2 = melb_df['Type'] == 'townhouse'
mask3 = melb_df['SellerG'] == 'McGrath'
print(melb_df[mask1 & mask2 & mask3].sort_values(
    by=['Date', 'AreaRatio'],
    ascending=[True, False],
    ignore_index=True
).loc[:, ['Date', 'AreaRatio']])

# Произведите сортировку столбца AreaRatio по убыванию. При этом индексы полученной таблицы замените на новые. 
# Какое значение площади здания находится в строке 1558? Ответ округлите до целого числа.
print(int(melb_df.sort_values(
    by='AreaRatio', 
    ignore_index=True,
    ascending=False
).loc[1558, 'BuildingArea']))

# Найдите таунхаусы (Type) с количеством жилых комнат (Rooms) больше 2. 
# Отсортируйте полученную таблицу сначала по возрастанию числа комнат, 
# а затем по убыванию средней площади комнат (MeanRoomsSquare). Индексы таблицы замените на новые. 
# Какая цена будет у объекта в строке 18? Ответ запишите в виде целого числа.
mask1 = melb_df['Type'] == 'townhouse'
mask2 = melb_df['Rooms'] > 2
print(int(melb_df[mask1&mask2].sort_values(
    by=['Rooms', 'MeanRoomsSquare'],
    ascending=[True, False],
    ignore_index=True
).loc[18, 'Price']))

# Применим агрегирующую функцию среднего к результату работы groupby(). 
# В качестве столбца для группировки возьмём столбец типа объекта недвижимости (Type):
print(melb_df.groupby(by='Type').mean())
#Мы получили таблицу, на пересечении строк и столбцов которой находятся 
# средние значения каждого числового признака в наших данных. Обратите внимание на структуру получившейся таблицы: 
# теперь на месте индексов стоят значения типа объекта недвижимости Type (house, townhouse, unit) 
# Примечание. Если мы хотим видеть тип объекта в качестве отдельного столбца таблицы, 
# мы можем выставить параметр as_index на False

# Как правило, нам не нужна информация обо всех столбцах, поэтому агрегирующие методы можно применять только к интересующему 
# нас столбцу. Например, давайте сравним средние цены на объекты в зависимости от их типа
print(melb_df.groupby('Type')['Price'].mean())
#Примечание. Обратите внимание, что, так как мы считаем только один показатель (среднее) для одного столбца, 
# в результате мы получаем объект Series.

# Теперь давайте выясним, какие регионы (Regionname) наиболее удалены от центра Мельбурна.
# Для этого найдём минимальное значение расстояния от центра города до объекта в зависимости от его региона. 
# Результат отсортируем по убыванию расстояния:
print(melb_df.groupby('Regionname')['Distance'].min().sort_values(ascending=False))

#Давайте построим таблицу для анализа продаж по месяцам. Для этого найдём количество продаж, 
# а также среднее и максимальное значения цен объектов недвижимости (Price), 
# сгруппированных по номеру месяца продажи (MonthSale). Результат отсортируем по количеству продаж в порядке убывания:
print(melb_df.groupby('MonthSale')['Price'].agg(
    ['count', 'mean', 'max']
).sort_values(by='count', ascending=False))
#Примечание. Обратите внимание, что, так как мы считаем несколько показателей для одного столбца, 
# в результате мы получаем объект DataFrame.

# Примечание. Если вам нужна полная информация обо всех основных статистических характеристиках внутри каждой группы, 
# вы можете воспользоваться методом agg(), передав в качестве его параметра строку 'describe'
print(melb_df.groupby('MonthSale')['Price'].agg('describe'))

#  После базовых математических функций наиболее частым агрегированием является подсчёт числа уникальных значений. 
# Так, например, мы можем вычислить число уникальных риелторских компаний в зависимости от региона, чтобы понять, 
# в каких регионах конкуренция на рынке недвижимости меньше. Это можно сделать, 
#передав в параметр метода agg() строку 'nunique'. 
# Более того, метод agg() поддерживает использование и других функций. 
# Передадим дополнительно встроенную функцию set, чтобы получить множество из агентств недвижимости, 
# которые работают в каждом из регионов
print(melb_df.groupby('Regionname')['SellerG'].agg(
    		['nunique', set]
))

# Сгруппируйте данные по признаку количества комнат и найдите среднюю цену объектов недвижимости в каждой группе. 
# В качестве ответа запишите количество комнат, для которых средняя цена наибольшая.
print(melb_df.groupby('Rooms')['Price'].mean().sort_values(ascending=False))

# Какой регион имеет наименьшую протяжённость по географической широте (Lattitude)?
# Для ответа на этот вопрос рассчитайте стандартное отклонение широты для каждого региона.
# В качестве ответа запишите название этого региона.
print(melb_df.groupby('Regionname')['Lattitude'].std().sort_values())

# Какая риелторская компания (SellerG) имеет наименьшую общую выручку 
# за период с 1 мая по 1 сентября (включительно) 2017 года?
# Для ответа на этот вопрос рассчитайте сумму продаж (Price) каждой компании в заданный период.
# Не забудьте перевести даты в формат datetime.
date1 = pd.to_datetime('2017-05-01')
date2 = pd.to_datetime('2017-09-01')
mask = (date1 <= melb_df['Date']) & (melb_df['Date']<= date2)
print(melb_df[mask].groupby('SellerG')['Price'].sum().sort_values(ascending=True))

## Сводные таблицы
# На самом деле мы с вами уже строили простейшие одномерные сводные таблицы с помощью метода groupby — 
# мы рассматривали сводную таблицу в контексте группировки по одному признаку. 
# Например, мы можем построить зависимость медианной цены и площади здания от числа комнат:
print(melb_df.groupby(['Rooms'])[['Price', 'BuildingArea']].median())

# Но можно пойти дальше и построить таблицу, в которой мы будем учитывать не только число комнат, 
# но и тип здания (Type). Для этого в параметрах метода groupby() укажем список из нескольких интересующих нас столбцов. 
# Чтобы финальный результат был представлен в виде таблицы, к результату агрегирования применим метод unstack():
print(melb_df.groupby(['Rooms', 'Type'])['Price'].mean().unstack())
# В результате мы получаем сводную таблицу, столбцы в которой представляют типы домов (house, townhouse, unit), 
# строки — число комнат, а на пересечении строк и столбцов находится средняя стоимость объекта с такими показателями.

# Давайте построим ту же самую таблицу, но уже с использованием метода pivot_table. В качестве параметра values 
# укажем столбец Price, в качестве индексов сводной таблицы возьмём Rooms, а в качестве столбцов — Type. 
# Агрегирующую функцию оставим по умолчанию (среднее). Дополнительно заменим пропуски в таблице на значение 0.
# Финальный результат для наглядности вывода округлим с помощью метода round() до целых
print(melb_df.pivot_table(
    values='Price',
    index='Rooms',
    columns='Type',
    fill_value=0
).round())

# А теперь давайте проанализируем продажи в каждом из регионов в зависимости от того, будний был день или выходной. 
# Для этого построим сводную таблицу, в которой строками будут являться названия регионов (Regionname), 
# а в столбцах будет располагаться наш «признак-мигалка» выходного дня (Weekend), который равен 1, если день был выходным, 
# и 0 — в противном случае. В качестве значений сводной таблицы возьмём количество продаж.
print(melb_df.pivot_table(
    values='Price',
    index='Regionname',
    columns='Weekend',
    aggfunc='count',
))

# Разберём ещё один пример. Найдём, как зависит средняя и медианная площадь участка (Landsize) от типа объекта (Type) 
# и его региона (Regionname). Чтобы посмотреть несколько статистических параметров, нужно передать в аргумент aggfunc 
# список из агрегирующих функций. Построим такую сводную таблицу, где пропущенные значения заменим на 0:
print(melb_df.pivot_table(
    values='Landsize',
    index='Regionname',
    columns='Type',
    aggfunc=['median', 'mean'],
    fill_value=0
))
# Обратите внимание на добавление дополнительных индексов столбцов median и mean. 
# Здесь медианное и среднее значения рассчитаны отдельно для каждой комбинации признаков.

# Давайте построим таблицу, в которой по индексам будут располагаться признаки метода продажи (Method) и 
# типа объекта (Type), по столбцам — наименование региона (Regionname), а на пересечении строк и столбцов 
# будет стоять медианная цена объекта (Price):
print(melb_df.pivot_table(
    values='Price',
    index=['Method','Type'],
    columns='Regionname',
    aggfunc='median',
    fill_value=0
))
# Первым индексом в таблице идёт метод продажи здания, далее для метода указывается тип продажи недвижимости. 
# По столбцам расположены регионы. В ячейках таблицы указана медианная цена для каждой такой комбинации.
# Такие таблицы уже сложнее читать, однако с помощью них можно более глубоко исследовать закономерности. 
# Например, можно видеть, что вне зависимости от метода продажи и региона цена на объекты типа house практически всегда выше, 
# чем на объекты другого типа.

# Давайте рассмотрим, что собой представляют столбцы сложной сводной таблицы.
# Возьмём сводную таблицу, которую мы создавали ранее:
pivot = melb_df.pivot_table(
    values='Landsize',
    index='Regionname',
    columns='Type',
    aggfunc=['median', 'mean'],
    fill_value=0
)
# Выведем её столбцы с помощью атрибута columns:
print(pivot.columns)
# В результате мы получаем объект MultiIndex. Этот объект хранит в себе шесть комбинаций пар столбцов 
# (два статистических параметра и три типа здания), то есть есть шесть возможных вариантов обращения к столбцам таблицы.
# Мультииндексы раскрываются подобно вложенным словарям — по очереди, как матрёшка. 
# Чтобы получить доступ к определённому столбцу, вы должны сначала обратиться к столбцу, который находится уровнем выше

# Так, из таблицы pivot мы можем получить средние значения площадей участков для типа здания unit, 
# просто последовательно обратившись по имени столбцов
print(pivot['mean']['unit'])

# Аналогично производится и фильтрация в данных. Например, если нам нужны регионы, 
# в которых средняя площадь здания для домов типа house меньше их медианной площади, 
# то мы можем найти их следующим образом
mask = pivot['mean']['house'] < pivot['median']['house']
filtered_pivot = pivot[mask]
print(filtered_pivot)

#Чтобы получить индексы отфильтрованной таблицы, можно воспользоваться атрибутом index и обернуть результат в список:
print(list(filtered_pivot.index))

# Составьте сводную таблицу, которая показывает зависимость медианной площади (BuildingArea) здания 
# от типа объекта недвижимости (Type) и количества жилых комнат в доме (Rooms). 
# Для какой комбинации признаков площадь здания наибольшая?
# В качестве ответа запишите эту комбинацию (тип здания, число комнат) через запятую, без пробелов.
pivot = melb_df.pivot_table(
    values='BuildingArea',
    index='Type',
    columns='Rooms',
    aggfunc='median',
    fill_value=0
)
print(pivot)

# Составьте сводную таблицу, которая показывает зависимость средней цены объекта недвижимости (Price) 
# от риелторского агентства (SellerG) и типа здания (Type).
# Во вновь созданной таблице найдите агентство, у которого средняя цена для зданий типа unit максимальна. 
# В качестве ответа запишите название этого агентства.
pivot = melb_df.pivot_table(
    values='Price',
    index='SellerG',
    columns='Type',
    aggfunc='mean',
)
max_unit_price = pivot['unit'].max()
print(pivot[pivot['unit'] == max_unit_price].index[0])